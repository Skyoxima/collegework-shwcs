{
  "Sem_IV-DAOA": {
    "DP_Coinchange.c": {
      "lang": "c",
      "code_string_literal": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid initializer(int noofcoins, int sum, int soln_matrix[][sum + 1]) //\n{\n  int i, j;\n\n  for (i = 0; i <= noofcoins; i++)\n  {\n    for (j = 0; j <= sum; j++)\n    {\n      soln_matrix[i][j] = 0;\n    }\n  }\n}\n\nvoid printer(int noofcoins, int sum, int matrix[][sum + 1]) //\n{\n  int i, j;\n\n  for (i = 0; i <= noofcoins; i++)\n  {\n    for (j = 0; j <= sum; j++)\n      printf(\"SM[%d][%d]: \\033[1m\\033[38;5;225m%d \\033[0m\", i, j, matrix[i][j]);\n    printf(\"\\n\");\n  }\n}\n\nint *coinchange(int noofcoins, int sum, int soln_matrix[][sum + 1], int *coins)\n{\n  int i = 1, j = 1, k;\n  static int *selected_coins;\n  selected_coins = (int *)malloc((sum) * sizeof(int));\n\n  for (j = 1; j <= sum; j++) //\n  {\n    for (i = 1; i <= noofcoins; i++) //\n    {\n      if (i == 1 && j < coins[i])\n        soln_matrix[i][j] = 999; //\n\n      else if (j < coins[i])\n        soln_matrix[i][j] = soln_matrix[i - 1][j];\n\n      else if (i == 1 || i == j)\n        soln_matrix[i][j] = 1 + soln_matrix[1][j - coins[i]];\n\n      else\n      {\n        if (soln_matrix[i - 1][j] < (1 + soln_matrix[i][j - coins[i]]))\n          soln_matrix[i][j] = soln_matrix[i - 1][j];\n        else\n          soln_matrix[i][j] = 1 + soln_matrix[i][j - coins[i]];\n      }\n    }\n  }\n\n  i = noofcoins;\n  j = sum;\n  k = 0;\n  selected_coins[k] = 0;\n  while (j > 0)\n  {\n    if (soln_matrix[i][j] == soln_matrix[i - 1][j])\n      i--;\n    else\n    {\n      selected_coins[k] = coins[i];\n      k++;\n      j -= coins[i];\n    }\n  }\n\n  selected_coins[k] = -1;\n  return selected_coins;\n}\n\nvoid main()\n{\n  int noofcoins = 0, i, j, k, sum;\n  int *coins;\n  int *selected_coins;\n  system(\"cls\");\n\n  printf(\"Enter the number of coins available: \");\n  scanf(\"%d\", &noofcoins);\n  coins = (int *)malloc((noofcoins) * sizeof(int));\n\n  printf(\"\\n\");\n  coins[0] = 0;\n  for (i = 1; i <= noofcoins; i++)\n  {\n    printf(\"Enter Coin %d: \", i);\n    scanf(\"%d\", &coins[i]);\n  }\n\n  printf(\"\\nNow enter the amount sum to be achieved: \");\n  scanf(\"%d\", &sum);\n\n  int soln_matrix[noofcoins + 1][sum + 1]; //\n  initializer(noofcoins, sum, soln_matrix);\n\n  selected_coins = coinchange(noofcoins, sum, soln_matrix, coins);\n  printf(\"\\nWork Matrix: \\n\\n\");\n  printer(noofcoins, sum, soln_matrix);\n\n  printf(\"\\nSelected coins to pay the sum: \");\n  for (i = 0; selected_coins[i] != -1; i++)\n    printf(\"%d \", selected_coins[i]);\n  printf(\"\\n\\n\");\n}",
      "comments": {
        "4": "// not an n x n matrix therefore two parameters needed, soln_matrix[][total noofcolumns]",
        "17": "//! V. IMP.: check how the matrix size is passed",
        "35": "// j goes from 1 to 8",
        "37": "// i goes from 1 to 3, this is a column-wise traversal, [1,1] [2,1] [3,1]",
        "40": "// infinity",
        "100": "// +1 because >> for e.g: rows ~ 0, 1, 2, 3 and columns ~ 0, 1, 2, 3, 4, 5, 6, 7, 8"
      },
      "OP_ss_dir": "OP_ss/DP_Coinchange.c"
    },
    "DP_Longest_Common_Subsequence.c": {
      "lang": "c",
      "code_string_literal": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid printer(int n1, int n2, int matrix[][n2 + 1]) //\n{\n  int i, j;\n\n  for (i = 0; i <= n1; i++)\n  {\n    for (j = 0; j <= n2; j++)\n      printf(\"SM[%d][%d]: \\033[1m\\033[38;5;225m%d \\033[0m\", i, j, matrix[i][j]);\n    printf(\"\\n\");\n  }\n}\n\nvoid longest_common_subsequence(int n1, int n2, char X[n1], char Y[n2], int sol_mx[][n2 + 1], int LCS[n2])\n{\n  int i, j, temp1, temp2, s_index = n2;\n\n  for (i = 0; i < n2; i++)\n    LCS[i] = -1;\n\n  for (i = 1; i <= n1; i++)\n  {\n    for (j = 1; j <= n2; j++)\n    {\n      if (X[i - 1] == Y[j - 1]) //\n        sol_mx[i][j] = 1 + sol_mx[i - 1][j - 1];\n      else\n      {\n        temp1 = sol_mx[i - 1][j]; //\n        temp2 = sol_mx[i][j - 1]; //\n\n        if (temp1 > temp2)\n          sol_mx[i][j] = temp1;\n        else\n          sol_mx[i][j] = temp2;\n      }\n    }\n  }\n\n  //\n  i = n1;\n  j = n2;\n  while (i != 0)\n  {\n    if (X[i - 1] == Y[j - 1])\n    {\n      LCS[j - 1] = j - 1;\n      i--;\n      j--;\n    }\n\n    else\n    {\n      temp1 = sol_mx[i - 1][j];\n      temp2 = sol_mx[i][j - 1];\n\n      if (temp1 > temp2)\n        i--;\n      else\n        j--;\n    }\n  }\n}\n\nvoid main()\n{\n  system(\"cls\");\n\n  int i, j, k, n1, n2;\n\n  printf(\"\\nEnter the number of characters in String 1: \");\n  scanf(\"%d\", &n1);\n  char X[n1];\n  getchar();\n  printf(\"Enter String 1: \");\n  fgets(X, n1 + 1, stdin); //\n  getchar();\n\n  printf(\"\\nEnter the number of characters in String 2: \");\n  scanf(\"%d\", &n2);\n  char Y[n2];\n  int LCS[n2];\n  getchar();\n  printf(\"Enter String 2: \");\n  fgets(Y, n2 + 1, stdin);\n  getchar();\n\n  int soln_mx[n1 + 1][n2 + 1]; //\n  for (i = 0; i <= n1; i++)\n    for (j = 0; j <= n2; j++)\n      soln_mx[i][j] = 0;\n\n  longest_common_subsequence(n1, n2, X, Y, soln_mx, LCS);\n  printf(\"\\n\\n\\033[4m\\033[38;5;207mFinal Matrix:\\n\\033[0m\");\n  printer(n1, n2, soln_mx);\n\n  printf(\"\\n\\033[1m\\033[4m\\033[38;5;210mCharacters of the subsequence:\\033[0m \");\n  for (i = 0; i < n2; i++)\n    if (LCS[i] != -1)\n      printf(\"%c \", Y[LCS[i]]);\n}\n\n//\n//\n//\n//\n//\n",
      "comments": {
        "5": "//! check how the matrix size is passed",
        "28": "//* since the indexing starts from zero for the char arrays",
        "32": "// upper element",
        "33": "// left element",
        "43": "// solution, the actual subsequence.. backtracking usage is necessary incase of multiple answers (although this program will not give multiple answers)",
        "79": "// simple gets is risky, it doesn't check for bounds set and can cause an overflow, hence using fgets",
        "91": "// here you give the size of the matrix so that is why +1, 0 indexing is disregarded",
        "106": "//! Index Glossary",
        "107": "// X - 0 to n1 - 1",
        "108": "// Y - 0 to n2 - 1",
        "109": "// soln_mx 0 to n1 and 0 to n2",
        "110": "// LCS - 0 to n2 - 1, same as Y"
      },
      "OP_ss_dir": "OP_ss/DP_Longest_Common_Subsequence.c"
    },
    "DP_Matrix_Multiplication.c": {
      "lang": "c",
      "code_string_literal": "#include <stdio.h>\n#include <stdlib.h>\n//\n\nvoid initializer(int n, int matrix[][n]) //\n{\n  int i, j;\n\n  for (i = 0; i < n; i++)\n  {\n    for (j = 0; j < n; j++)\n      if (j >= i)\n        matrix[i][j] = 0;\n      else\n        matrix[i][j] = -1;\n  }\n}\n\nvoid printer(int n, int matrix[][n])\n{\n  int i, j;\n\n  for (i = 0; i < n; i++)\n  {\n    for (j = 0; j < n; j++)\n      if (j >= i)\n        printf(\"%d \", matrix[i][j]);\n      else\n        printf(\"  \");\n    printf(\"\\n\");\n  }\n}\n\nvoid print_parenthesis(int n, int matrix[][n], int i, int j)\n{\n  if (i == j)\n    printf(\" M%d \", i);\n  else\n  {\n    printf(\"(\");\n    print_parenthesis(n, matrix, i, matrix[i][j]);\n    print_parenthesis(n, matrix, matrix[i][j] + 1, j);\n    printf(\")\");\n  }\n}\n\nvoid main()\n{\n  int n = 0, i, j, k, min = 32767, temp, min_k, count, gap = 1; //\n  int *dims;                                                    //\n  system(\"cls\");\n\n  //\n  printf(\"Enter the number of matrices in the sequence: \");\n  scanf(\"%d\", &n);\n  dims = (int *)malloc((n + 1) * sizeof(int));\n  //\n\n  printf(\"\\n\");\n  for (i = 0; i <= n; i++)\n  {\n    printf(\"Enter P%d: \", i);\n    scanf(\"%d\", &dims[i]);\n  }\n\n  //\n  int substructure[n][n]; //\n  initializer(n, substructure);\n\n  //\n  int parenthesis[n][n];\n  initializer(n, parenthesis);\n\n  //\n  count = n - 1; //\n  while (count > 0)\n  {\n    for (i = 0, j = gap; j < n; i++, j++)\n    {\n      for (k = i; k < j; k++)\n      {\n        temp = substructure[i][k] + substructure[k + 1][j] + (dims[i] * dims[k + 1] * dims[j + 1]);\n        printf(\"\\ni = %d, j = %d, k = %d, %d\", i, j, k, temp); //\n        if (temp < min)                                        //\n        {\n          min = temp;\n          min_k = k;\n        }\n      }\n      substructure[i][j] = min;\n      parenthesis[i][j] = min_k;\n      printf(\"\\nFor cell [%d, %d], chosen value: \\033[0;32m %d units. \\033[0m\\n\", i, j, min);\n      min = 32767;\n    }\n    gap++;\n    count--;\n  }\n\n  printf(\"\\n\\nOptimal Substructure: \\n\");\n  printer(n, substructure);\n  printf(\"\\nTherefore the optimum cost for matrix chain multiplication is: \\033[1;32m %d units.\\033[0m\", substructure[0][n - 1]);\n\n  printf(\"\\n\\nParenthesization Matrix (index-based): \\n\");\n  printer(n, parenthesis);\n  printf(\"\\nTherefore, the optimal parenthesization (index-based) is: \\n\");\n\n  print_parenthesis(n, parenthesis, 0, n - 1);\n}\n",
      "comments": {
        "3": "// TBR - Towards Bottom Right (Diagonal Direction)",
        "5": "// C99 allows this, column size should be passed before the matrix",
        "49": "// setting min to effective inf., this will be resetted after each cell gets it's min",
        "50": "// gap is the difference between i and j for each diagonal",
        "53": "// take input, asking for number of matrices.",
        "57": "// UP: number of dimensions will be +1 of number of matrices needed",
        "66": "// substructure preparation",
        "67": "// C99 allows this",
        "70": "// parenthesization preparation",
        "74": "// optimization, indexing starts from zero hence a slight change in the formula",
        "75": "// number of TBR diagonals to be traversed",
        "83": "// clarification purpose",
        "84": "// of all values for all k, choosing the minimum one"
      },
      "OP_ss_dir": "OP_ss/DP_Matrix_Multiplication.c"
    },
    "Greedy_Coinchange.c": {
      "lang": "c",
      "code_string_literal": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid main()\n{\n  int i, j, k = 0, noofcoins, temp, sum;\n  system(\"cls\");\n  printf(\"Enter the number of coins: \");\n  scanf(\"%d\", &noofcoins);\n  int *coins = (int *)malloc(noofcoins * sizeof(int));\n\n  printf(\"Enter the coins: (preferably descending order): \");\n  for (i = 0; i < noofcoins; i++)\n    scanf(\"%d\", &coins[i]);\n\n  for (i = 1; i < noofcoins; i++)\n    for (j = 0; j < noofcoins - i; j++)\n      if (coins[j + 1] > coins[j])\n      {\n        temp = coins[j + 1];\n        coins[j + 1] = coins[j];\n        coins[j] = temp;\n      }\n\n  printf(\"\\nEnter the Sum to be repaid: \");\n  scanf(\"%d\", &sum);\n\n  int *selected_coins = (int *)malloc(sum * sizeof(int));\n  while (sum > 0)\n  {\n    for (i = 0; i < noofcoins; i++)\n      if (coins[i] <= sum)\n      {\n        sum -= coins[i];\n        selected_coins[k++] = coins[i];\n        break;\n      }\n  }\n  printf(\"\\nSelected Coins: \");\n  for (i = 0; i < k; i++)\n    printf(\"%d \", selected_coins[i]);\n}",
      "comments": {},
      "OP_ss_dir": "OP_ss/Greedy_Coinchange.c"
    },
    "Greedy_Job_Scheduling.c": {
      "lang": "c",
      "code_string_literal": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Job\n{\n  int jobno, deadline, profit;\n} Job;\n\nvoid main()\n{\n  int i, j, k, noofjobs, MDL = -1, INDL, total_profit = 0, isnc = 0;\n  Job temp;\n  printf(\"\\nEnter the number of jobs: \");\n  scanf(\"%d\", &noofjobs);\n  Job jobs[noofjobs];\n\n  printf(\"Enter the profits for each job: \");\n  for (i = 0; i < noofjobs; i++)\n    scanf(\"%d\", &jobs[i].profit);\n\n  printf(\"Enter the deadline for each job: \");\n  for (i = 0; i < noofjobs; i++)\n  {\n    scanf(\"%d\", &jobs[i].deadline);\n    if (jobs[i].deadline > MDL)\n      MDL = jobs[i].deadline;\n    jobs[i].jobno = i + 1;\n  }\n\n  for (i = 1; i < noofjobs; i++)\n    for (j = 0; j < noofjobs - i; j++)\n    {\n      if (jobs[j + 1].profit > jobs[j].profit)\n      {\n        temp = jobs[j + 1];\n        jobs[j + 1] = jobs[j];\n        jobs[j] = temp;\n      }\n    }\n\n  Job schedule[MDL];\n  Job not_completed[MDL];\n  for (i = 0; i < MDL; i++)\n    schedule[i].jobno = 0;\n\n  for (i = 0; i < noofjobs; i++)\n  {\n    INDL = jobs[i].deadline;\n    for (j = INDL - 1; j >= 0; j--)\n    {\n      if (schedule[j].jobno == 0)\n      {\n        schedule[j] = jobs[i];\n        total_profit += schedule[j].profit;\n        break;\n      }\n      if (j == 0)\n        not_completed[isnc++] = jobs[i];\n    }\n  }\n\n  printf(\"\\n\\nOptimal Job Sequence: \\n\");\n  for (i = 0; i < MDL; i++)\n    if (schedule[i].jobno != 0)\n      printf(\"J%d - Completed at %d\\n\", schedule[i].jobno, i + 1);\n\n  printf(\"Jobs not scheduled: \");\n  for (i = 0; i < isnc; i++)\n    printf(\"J%d \", not_completed[i].jobno);\n\n  printf(\"\\n\\nMaximum profit: \\033[1m\\033[38;5;223m%d units.\\033[0m\", total_profit);\n}",
      "comments": {},
      "OP_ss_dir": "OP_ss/Greedy_Job_Scheduling.c"
    },
    "KMP_String_Matching.py": {
      "lang": "py",
      "code_string_literal": "text = [i for i in input(\"Enter the main String: \")]\nlt = len(text)\npattern = [i for i in input(\"Enter the Pattern: \")]\nlp = len(pattern)\noccurences = [999]\ntemp = [999]\nfor i in pattern:\n  if i not in temp:\n    temp.append(i)\n    occurences.append(0)\n  else:\n    temp.append('\\0')\n    occurences.append(temp.index(i))\npattern.insert(0, '\\0')\nprint(pattern, occurences)\n\ni = 0\nj = 0\nwhile (i < lt):\n  if (text[i] == pattern[j + 1]):\n    i += 1\n    j += 1\n    if (j == lp):\n      print(\"Pattern found at index\", i - lp, \"of the main string\")\n      break\n\n  elif ((text[i] != pattern[j + 1]) and j != 0):\n    j = occurences[j]\n  elif (text[i] != pattern[j + 1]) and j == 0:\n    i += 1\n\nif (j < lp):\n  print(\"Pattern not found...\")\n",
      "comments": {},
      "OP_ss_dir": "OP_ss/KMP_String_Matching.py"
    },
    "Knapsack_Problem.c": {
      "lang": "c",
      "code_string_literal": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Item\n{\n  int item_no, value, weight;\n  float VW_ratio, fraction;\n} Item;\n\ntypedef struct Knapsack\n{\n  int max_capacity, curr_no_items;\n  float total_weight, curr_capacity, total_profit;\n  Item *included_item_list;\n} Sack;\n\nItem *take_items(int n)\n{\n  Item *item_list = (Item *)malloc(n * sizeof(Item));\n  int i, value, weight;\n  //\n  for (i = 0; i < n; i++)\n  {\n    printf(\"For Item %d, enter it's Profit(Vi) & Weight(Wi): \", i + 1);\n    scanf(\"%d, %d\", &value, &weight);\n    item_list[i].item_no = i + 1;\n    item_list[i].value = value;\n    item_list[i].weight = weight;\n    item_list[i].VW_ratio = (float)value / weight;\n    item_list[i].fraction = 1.0;\n  }\n\n  return item_list;\n}\n\nvoid sort_wrt_VW_ratio_descendingly(Item *item_list, int noofitems)\n{\n  int i, j;\n  Item temp;\n\n  for (i = 1; i < noofitems; i++)\n  {\n    for (j = 0; j < noofitems - i; j++)\n    {\n      if (item_list[j].VW_ratio < item_list[j + 1].VW_ratio)\n      {\n        temp = item_list[j];\n        item_list[j] = item_list[j + 1];\n        item_list[j + 1] = temp;\n      }\n    }\n  }\n}\n\nSack fill_sack(Item *item_list, int noofitems)\n{\n  int i, is_full = 0;\n  float fraction = 1.0;\n  Sack sack; //\n\n  printf(\"\\nEnter the Maximum Capacity of the Knapsack: \");\n  scanf(\"%d\", &sack.max_capacity);\n  sack.curr_capacity = sack.max_capacity;\n  sack.total_profit = 0.0;\n  sack.total_weight = 0.0;\n  sack.curr_no_items = 0;\n  sack.included_item_list = (Item *)calloc(noofitems, sizeof(Item));\n\n  for (i = 0; i < noofitems; i++)\n  {\n    if (is_full == 0)\n    {\n      if ((item_list[i].weight > sack.curr_capacity))\n      {\n        fraction = (float)(sack.max_capacity - sack.total_weight) / item_list[i].weight;\n        item_list[i].fraction = fraction;\n        is_full = 1;\n      }\n\n      sack.included_item_list[sack.curr_no_items] = item_list[i];\n      sack.curr_no_items++;\n      sack.curr_capacity -= item_list[i].weight * fraction; //\n      sack.total_profit += item_list[i].value * fraction;\n      sack.total_weight += item_list[i].weight * fraction; //\n    }\n  }\n  return sack;\n}\n\nvoid main()\n{\n  int n, i, j, k, value, weight;\n  Item *item_list = NULL;\n  Sack sack;\n  //\n  system(\"cls\");\n\n  printf(\"\\nEnter the number of items: \");\n  scanf(\"%d\", &n);\n\n  item_list = take_items(n);\n  //\n\n  printf(\"\\nInitial Table: \");\n  printf(\"\\nItem No.   Values   Weights       V/W\");\n  for (i = 0; i < n; i++)\n    printf(\"\\n  %d          %d         %d        %.2f\", item_list[i].item_no,\n           item_list[i].value,\n           item_list[i].weight,\n           item_list[i].VW_ratio);\n\n  sort_wrt_VW_ratio_descendingly(item_list, n);\n  printf(\"\\n\\nSorted Table (w.r.t V/W): \");\n  printf(\"\\nItem No.   Values   Weights       V/W\");\n  for (i = 0; i < n; i++)\n    printf(\"\\n  %d          %d         %d        %.2f\", item_list[i].item_no,\n           item_list[i].value,\n           item_list[i].weight,\n           item_list[i].VW_ratio);\n\n  sack = fill_sack(item_list, n);\n  printf(\"\\n\\nKnapsack Table (Items added to the knapsack): \");\n  printf(\"\\nItem No.     Values        Weights     Fractions\");\n  for (i = 0; i < sack.curr_no_items; i++)\n  {\n    if (sack.included_item_list[i].fraction != 1.0)\n      printf(\"\\033[1;31m\"); //\n\n    printf(\"\\n  %d          %.2f         %.2f        %.2f\", sack.included_item_list[i].item_no,\n           (float)sack.included_item_list[i].value * sack.included_item_list[i].fraction,\n           (float)sack.included_item_list[i].weight * sack.included_item_list[i].fraction,\n           sack.included_item_list[i].fraction);\n    printf(\"\\033[0m\");\n  }\n\n  printf(\"\\n\\nCurrent weight of the Knapsack: %.2f\\nProfit earned from the selected items: \\033[1;32m %.2f \\033[0m\\n\\n\", sack.total_weight, sack.total_profit);\n}",
      "comments": {
        "21": "// when you use the object (array) itself to traverse / fill the data in, use '.', if you use a pointer to that object, use ' -> '",
        "59": "// making a direct Knapsack object",
        "82": "// if the whole item is being added to the sack then multiplying the fraction (which would be 1.0) won't change anything, otherwise it will change the values as required",
        "84": "// should be equal to max_capacity ideally at the end of all iterations, can be less but not greater",
        "95": "// Item** test;  //if you really want to use '->' operator, pointer to a pointer(first index of a dynamically allocated array)",
        "102": "// test = item_list;",
        "127": "// ANSI escape sequence for formatted text, format (color) should only apply if the last item is not whole"
      },
      "OP_ss_dir": "OP_ss/Knapsack_Problem.c"
    },
    "Kruskals_Algorithm_w_Dynamic_Graph.c": {
      "lang": "c",
      "code_string_literal": "//\n//\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#define MAX 30\n\ntypedef struct Graph_Edge\n{\n  int src, dest, weight; //\n} Edge;\n\ntypedef struct Graph_Node\n{\n  int data;                 //\n  int weight;               //\n  struct Graph_Node *link;  //\n  Edge indv_edge_list[MAX]; //\n  int no_of_edges;\n} Node;\n\n//\nEdge edge_list[3 * MAX];\nint total_edge_count = 0;\n\ntypedef struct Graph\n{\n  Node *head[MAX]; //\n} Graph;\n\nGraph *readGraph(int n) //\n{\n  int i, j, links, from, to, weight;\n  Graph *graph = (Graph *)malloc(sizeof(Graph));\n\n  for (i = 0; i < n; i++)\n  {\n    graph->head[i] = (Node *)malloc(sizeof(Node));\n    graph->head[i]->link = NULL;\n    graph->head[i]->data = i;\n    graph->head[i]->weight = 0; //\n\n    printf(\"\\nFor Node %d:\\n\", i);\n    printf(\"Enter the number of Edges: \");\n    scanf(\"%d\", &links);\n    graph->head[i]->no_of_edges = links;\n\n    for (j = 0; j < links; j++)\n    {\n      printf(\"Enter edge (format:- dest, weight): \");\n      scanf(\"%d, %d\", &to, &weight);\n\n      //\n      edge_list[total_edge_count].src = i;\n      edge_list[total_edge_count].dest = to;\n      edge_list[total_edge_count].weight = weight;\n      total_edge_count += 1;\n\n      //\n      graph->head[i]->indv_edge_list[j].src = i;\n      graph->head[i]->indv_edge_list[j].dest = to;\n      graph->head[i]->indv_edge_list[j].weight = weight;\n\n      Node *temp = (Node *)malloc(sizeof(Node));\n      temp->data = to;\n      temp->weight = weight; //\n      temp->link = NULL;\n\n      Node *current = graph->head[i]; //\n      while (current->link != NULL)\n        current = current->link;\n\n      current->link = temp;\n    }\n  }\n\n  return graph;\n}\n\nvoid adj_list(Graph *graph, int n)\n{\n  printf(\"Adjacency List:\\n\");\n  for (int i = 0; i < n; i++)\n  {\n    Node *p = graph->head[i];\n    for (p = graph->head[i]; p->link != NULL; p = p->link)\n    {\n      printf(\"%d (%d) --> \", p->data, p->weight);\n    }\n    printf(\"%d (%d) --> NULL\", p->data, p->weight);\n    printf(\"\\n\");\n  }\n}\n\nvoid print_edges_per_Node(Graph *graph, int n)\n{\n  int i, j;\n\n  for (i = 0; i < n; i++)\n  {\n    printf(\"\\nFor Node %d:\\n\", i);\n    for (j = 0; j < graph->head[i]->no_of_edges; j++)\n    {\n      printf(\"Source: %d, Destination: %d, Weight: %d\\n\",\n              graph->head[i]->indv_edge_list[j].src,\n              graph->head[i]->indv_edge_list[j].dest,\n              graph->head[i]->indv_edge_list[j].weight); //\n    }\n  }\n}\n\nvoid sort_edges_by_weight(Edge *total_edge_list)\n{\n  int i, j;\n  Edge temp;\n  for (i = 1; i < total_edge_count; i++)\n  {\n    for (j = 0; j < total_edge_count - i; j++)\n    {\n      if (total_edge_list[j].weight > total_edge_list[j + 1].weight)\n      {\n        temp = total_edge_list[j];\n        total_edge_list[j] = total_edge_list[j + 1];\n        total_edge_list[j + 1] = temp;\n      }\n    }\n  }\n}\n\nEdge *remove_repeats(Edge *total_edge_list, Edge *new_list)\n{\n  int i, j = 0, k = 0;\n\n  for (i = 0; i < total_edge_count; i++)\n  {\n    for (j = i + 1; j < total_edge_count; j++)\n    {\n      if ((total_edge_list[j].weight == total_edge_list[i].weight) && (total_edge_list[j].src == total_edge_list[i].dest && total_edge_list[j].dest == total_edge_list[i].src))\n      {\n        new_list[k] = total_edge_list[i];\n        k++;\n        break;\n      }\n    }\n  }\n  return new_list;\n}\n\nvoid update_parent(int *parents_array, Edge curr_edge, int noofnodes)\n{\n  int i;\n  for (i = 0; i < noofnodes; i++)\n    if (parents_array[i] == parents_array[curr_edge.dest])\n      parents_array[i] = parents_array[curr_edge.src];\n}\n\nvoid Kruskals(Edge *prcsd_edge_list, int noofnodes)\n{\n  Edge *MST = (Edge *)malloc((noofnodes - 1) * sizeof(Edge));\n  int *parents = (int *)malloc(((noofnodes) * sizeof(int)));\n  int i = 0, j, k = 0, min_cost = 0;\n\n  for (j = 0; j < noofnodes; j++)\n    parents[j] = j;\n\n  for (i = 0; i < total_edge_count / 2; i++)\n  {\n    if (k == noofnodes - 1)\n      break;\n\n    if (parents[prcsd_edge_list[i].src] != parents[prcsd_edge_list[i].dest])\n    {\n      MST[k] = prcsd_edge_list[i];\n      update_parent(parents, prcsd_edge_list[i], noofnodes);\n      k++;\n    }\n  }\n\n  printf(\"\\n\\nThe Minimum Spanning Tree: \");\n  for (j = 0; j < (noofnodes - 1); j++)\n  {\n    printf(\"\\n%d -> %d : %d\", MST[j].src, MST[j].dest, MST[j].weight);\n    min_cost += MST[j].weight;\n  }\n  printf(\"\\nCost of the Minimum Spanning Tree: %d units.\", min_cost);\n}\n\nvoid main()\n{\n  int i, j, noofnodes, count;\n  Graph *Main_Graph = NULL;\n  system(\"cls\");\n  Edge new_list[3 * MAX];\n\n  printf(\"Enter the number of Nodes required in the Graph: \");\n  scanf(\"%d\", &noofnodes);\n\n  Main_Graph = readGraph(noofnodes); //\n  printf(\"\\n\");\n\n  adj_list(Main_Graph, noofnodes); //\n  printf(\"\\n\\n\");\n\n  printf(\"\\nAll the Edges: \\n\");\n  for (i = 0; i < total_edge_count; i++)\n    printf(\"(%d, %d, %d) \", edge_list[i].src, edge_list[i].dest, edge_list[i].weight);\n\n  sort_edges_by_weight(edge_list); //\n  printf(\"\\nAll the Edges (Sorted by weights): \\n\");\n  for (i = 0; i < total_edge_count; i++)\n    printf(\"(%d, %d, %d) \", edge_list[i].src, edge_list[i].dest, edge_list[i].weight);\n\n  remove_repeats(edge_list, new_list); //\n  printf(\"\\nRepeats removed: \\n\");\n  for (i = 0; i < total_edge_count / 2; i++)\n    printf(\"(%d, %d, %d) \", new_list[i].src, new_list[i].dest, new_list[i].weight);\n\n  Kruskals(new_list, noofnodes);\n  system(\"pause\");\n}\n\n//\n//\n",
      "comments": {
        "1": "// Dynamic Graph Implementation (HN Sir method)",
        "2": "//  Here we first take in the number of nodes the graph will have.",
        "3": "//  Then we ask the edges it will make with others, along with respective weights of that edges.",
        "11": "// each edge has 3 values: source, destination and weight",
        "16": "// has the node/vertex Number",
        "17": "//! when the node is the destination, in the adjacency list the weight to get to it will be stored here",
        "18": "// address of the node the current node is connected to cause linked list",
        "19": "//?-- TRY THIS? --done",
        "23": "//! Global array for all the edges, had to keep it global cause readGraph is returning 'graph'",
        "29": "// array of Node type linked list",
        "32": "// taking in the number of nodes",
        "42": "//*each starting node's weight-to-get-to will be zero",
        "54": "//! this is essentially making a list of all the edges, global 'edge_list'",
        "60": "//! this is giving each node's edge_list a 'Edge' type data",
        "67": "// weight to get to this node",
        "70": "//*Node currently indexed by i in the head array of the Graph Structure",
        "108": "// for this one, 'source' can be removed...",
        "199": "//!",
        "202": "//!",
        "209": "//!",
        "214": "//!",
        "223": "// in the Node structure definition, I have written data and weight separately to write comments, no other reason",
        "224": "// What if each node has an array of Edges, just that it will only contain all the edges that node is the source of -- implemented"
      },
      "OP_ss_dir": "OP_ss/Kruskals_Algorithm_w_Dynamic_Graph.c"
    },
    "MergeSort.py": {
      "lang": "py",
      "code_string_literal": "#\nfrom numpy import floor\n\ndef mergesort(arr, lb, ub):\n\tif (lb < ub):  #\n\t\tmid = int(floor((lb + ub) / 2))\n\t\tmergesort(arr, lb, mid)\n\t\tmergesort(arr, mid + 1, ub)\n\t\taux_arr = merge(arr, lb, mid, ub)\n\ndef merge(arr, lb, mid, ub):\n\taux_arr = []  #\n\ti = lb\n\tj = mid + 1\n\n\twhile (i <= mid and j <= ub):\n\t\tif (arr[i] < arr[j]):\n\t\t\taux_arr.append(arr[i])\n\t\t\ti += 1\n\t\telse:\n\t\t\taux_arr.append(arr[j])\n\t\t\tj += 1\n\n\twhile (i <= mid):  #\n\t\taux_arr.append(arr[i])\n\t\ti += 1\n\n\twhile (j <= ub):\n\t\taux_arr.append(arr[j])\n\t\tj += 1\n\n\ti = lb\n\tj = 0\n\twhile (i <= ub):\n\t\t#\n\t\tarr[i] = aux_arr[j]\n\t\ti += 1\n\t\tj += 1\n\narray = [int(x) for x in input(\"Enter an array of numbers (Space separated): \").split()]\nmergesort(array, 0, len(array) - 1)\nprint(\"Merge-sorted Array: \", *array, sep=\" \")",
      "comments": {
        "1": "# Python program to implement Mergesorting on a given array",
        "5": "# similar to quicksorting, atleast 2 distinct array elements required",
        "12": "# auxiliary array to temporarily store sorted sub-arrays",
        "24": "# emptying sub-array if necessary",
        "35": "# main array being sorted using auxiliary array's content for each call of merge function"
      },
      "OP_ss_dir": "OP_ss/MergeSort.py"
    },
    "Minmax.py": {
      "lang": "py",
      "code_string_literal": "def minmax(arr, lb, ub):\n  if (lb == ub):  #\n    return (arr[lb], arr[lb])\n  elif (ub - lb == 1):  #\n    if (arr[lb] < arr[ub]):\n      return (arr[lb], arr[ub])\n    else:\n      return (arr[ub], arr[lb])\n  else:  #\n    mid = (lb + ub) // 2\n    [l_sub_min, l_sub_max] = minmax(arr, lb, mid)\n    [r_sub_min, r_sub_max] = minmax(arr, mid + 1, ub)\n\n    #\n    if (l_sub_min < r_sub_min):\n      mini = l_sub_min\n    else:\n      mini = r_sub_min\n\n    if (l_sub_max < r_sub_max):\n      maxi = r_sub_max\n    else:\n      maxi = l_sub_max\n\n    return (mini, maxi)\n#\n\n\narray = [int(array_ele) for array_ele in input(\n  \"Enter the array elements\\n(Delimiter = space): \").split()]\n[mini, maxi] = minmax(array, 0, len(array) - 1)\nprint(\"\\nMaximum: {}\\nMinimum: {}\".format(maxi, mini))",
      "comments": {
        "2": "# strictly one array element in consideration",
        "4": "# strictly two array elements in consideration",
        "9": "# more than 2 elements sub-arrays",
        "14": "# For combinations, code reachable only when sub-array(s) at hand as 2 elements at the most",
        "26": "# * if block is the recursion ending statement group"
      },
      "OP_ss_dir": "OP_ss/Minmax.py"
    },
    "Prims_Algorithm_w_Dynamic_Graph.c": {
      "lang": "c",
      "code_string_literal": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 20\n\ntypedef struct Graph_Edge\n{\n  int src, dest, weight;\n} Edge;\n\ntypedef struct Edges_array\n{\n  Edge *edge_list; //\n  int noofedges;\n} Edge_list;\n\ntypedef struct Graph_Node\n{\n  int data;\n  int weight;\n  struct Graph_Node *link;\n  Edge_list indv_edge_list;\n} Node;\n\ntypedef struct Graph\n{\n  Node *head[MAX]; //\n} Graph;\n\nGraph *readGraph(int n, Edge_list *all_edges) //\n{\n  int i, j, links, from, to, weight;\n  Graph *graph = (Graph *)malloc(sizeof(Graph));\n  all_edges->edge_list = (Edge *)malloc((n * (n - 1)) * sizeof(Edge)); //\n  all_edges->noofedges = 0;\n\n  for (i = 0; i < n; i++)\n  {\n    graph->head[i] = (Node *)malloc(sizeof(Node));\n    graph->head[i]->link = NULL;\n    graph->head[i]->data = i;\n    graph->head[i]->weight = 0;\n\n    printf(\"\\nFor Node %d:\\n\", i);\n    printf(\"Enter the number of Edges: \");\n    scanf(\"%d\", &links);\n    graph->head[i]->indv_edge_list.edge_list = (Edge *)malloc(links * sizeof(Edge));\n    graph->head[i]->indv_edge_list.noofedges = 0;\n\n    for (j = 0; j < links; j++)\n    {\n      printf(\"Enter edge (format:- dest, weight): \");\n      scanf(\"%d, %d\", &to, &weight);\n\n      //\n      graph->head[i]->indv_edge_list.edge_list[j].src = i;\n      graph->head[i]->indv_edge_list.edge_list[j].dest = to;\n      graph->head[i]->indv_edge_list.edge_list[j].weight = weight;\n      graph->head[i]->indv_edge_list.noofedges++;\n\n      Node *temp = (Node *)malloc(sizeof(Node));\n      temp->data = to;\n      temp->weight = weight;\n      temp->link = NULL;\n\n      Node *current = graph->head[i];\n      while (current->link != NULL)\n        current = current->link;\n\n      current->link = temp;\n\n      all_edges->edge_list[all_edges->noofedges].src = i;\n      all_edges->edge_list[all_edges->noofedges].dest = to;\n      all_edges->edge_list[all_edges->noofedges].weight = weight;\n      all_edges->noofedges++;\n    }\n  }\n\n  return graph;\n}\n\nvoid adj_list(Graph *graph, int n)\n{\n  printf(\"Adjacency List:\\n\");\n  for (int i = 0; i < n; i++)\n  {\n    Node *p = graph->head[i];\n    for (p = graph->head[i]; p->link != NULL; p = p->link)\n    {\n      printf(\"[%d] (%d) --> \", p->data, p->weight);\n    }\n    printf(\"[%d] (%d) --> NULL\", p->data, p->weight);\n    printf(\"\\n\");\n  }\n}\n\nEdge find_min_weight_edge(Edge_list obj1, int *included) //\n{\n  int i, s, d;\n  Edge min;\n  min.weight = 32767;\n\n  for (i = 0; i < obj1.noofedges; i++)\n  {\n    s = obj1.edge_list[i].src;\n    d = obj1.edge_list[i].dest;\n\n    if (!(included[s] == 1 && included[d] == 1))\n    {\n      if (min.weight > obj1.edge_list[i].weight)\n        min = obj1.edge_list[i];\n    }\n  }\n\n  return min;\n}\n\nEdge_list Prims(Graph *graph, int noofnodes, Edge_list all_edges)\n{\n  int i, j, k;\n  Edge min_edge;\n  Edge_list MST;\n  int *included = (int *)malloc(noofnodes * sizeof(int));\n\n  min_edge.weight = 32767; //\n  MST.edge_list = (Edge *)malloc((noofnodes - 1) * sizeof(Edge));\n  MST.noofedges = 0;\n\n  for (i = 0; i < noofnodes; i++) //\n    included[i] = 0;\n\n  min_edge = find_min_weight_edge(all_edges, included);\n  included[min_edge.src] = 1; //\n  min_edge.weight = 32767;\n\n  while (MST.noofedges != noofnodes - 1)\n  {\n    for (i = 0; i < noofnodes; i++)\n    {\n      if (included[i] == 1)\n        if (find_min_weight_edge(graph->head[i]->indv_edge_list, included).weight < min_edge.weight)\n          min_edge = find_min_weight_edge(graph->head[i]->indv_edge_list, included);\n    }\n\n    MST.edge_list[MST.noofedges] = min_edge;\n    included[min_edge.dest] = 1;\n    min_edge.weight = 32767;\n    MST.noofedges++;\n  }\n  return MST;\n}\n\nvoid main()\n{\n  int i, j, noofnodes, final_cost = 0;\n  Graph *Main_Graph = NULL;\n  Edge_list all_edges, MST;\n  Edge_list *p_all_edges = &all_edges; //\n  system(\"cls\");\n\n  printf(\"Enter the number of Nodes required in the Graph: \");\n  scanf(\"%d\", &noofnodes);\n\n  Main_Graph = readGraph(noofnodes, p_all_edges);\n  printf(\"\\n\");\n\n  adj_list(Main_Graph, noofnodes);\n  printf(\"\\n\");\n\n  printf(\"\\nAll the Edges: \\n\");\n  for (i = 0; i < all_edges.noofedges; i++)\n    printf(\"(%d, %d, %d) \", all_edges.edge_list[i].src, all_edges.edge_list[i].dest, all_edges.edge_list[i].weight);\n\n  MST = Prims(Main_Graph, noofnodes, all_edges);\n  printf(\"\\n\\nEdges included in the Minimum Spanning Tree:\");\n  for (i = 0; i < MST.noofedges; i++)\n  {\n    printf(\"\\n%d <-> %d : %d \", MST.edge_list[i].src, MST.edge_list[i].dest, MST.edge_list[i].weight);\n    final_cost += MST.edge_list[i].weight;\n  }\n  printf(\"\\n\\nCost of the Minimum Spanning Tree: \\033[1;32m%d units.\\033[0m\\n\", final_cost);\n  system(\"pause\");\n}",
      "comments": {
        "12": "// dynamic array of edges",
        "26": "// array of pointers of Node type linked list, pointers used cause malloc will be used to form a SLL",
        "29": "// taking in the number of nodes and a pointer to the object of Edge_list",
        "33": "// maximum possible total no. of edges for an directed (bidrected) graph having 'n' vertices",
        "54": "// a bit too lengthy haha",
        "96": "// returns minimum edge of a node",
        "124": "// set infinite (so that the first one is always considered minimum)",
        "128": "// for excluding already included node (in the MST) checking",
        "132": "// marking the first node (node which is the source of minimum weight among all the edges of the graph) as included.",
        "157": "// a pointer to the Edge_list object has to be made to pass it in the readGraph function and create the whole edgelist without having to return the Edge_list object as readGraph is returning a Graph* already"
      },
      "OP_ss_dir": "OP_ss/Prims_Algorithm_w_Dynamic_Graph.c"
    },
    "QuickSort.py": {
      "lang": "py",
      "code_string_literal": "#\n#\n\ndef quicksort(arr, lb, ub):\n\tif (lb < ub):  #\n\t\tprev_pivot = partition(arr, lb, ub)\n\t\tquicksort(arr, lb, prev_pivot - 1)\n\t\tquicksort(arr, prev_pivot + 1, ub)\n\n\ndef partition(arr, lb, ub):\n\tstart = lb\n\tend = ub\n\t#\n\tpivot = arr[lb]\n\t#\n\n\twhile (start < end):\n\t\t#\n\t\twhile (start < (len(arr) - 1) and arr[start] <= pivot):\n\t\t\tstart += 1\n\n\t\twhile (arr[end] > pivot):\n\t\t\tend -= 1\n\n\t\tif (start < end):\n\t\t\tarr[end], arr[start] = arr[start], arr[end]\n\n\tif (arr.index(pivot) != end):  #\n\t\tarr[end], arr[lb] = arr[lb], arr[end]\n\n\treturn end  #\n\n\narray = []\nx = 0\nwhile (x != -1):\n\tx = int(input(\"Enter array element, (-1 to stop): \"))\n\tif (x != -1):\n\t\tarray.append(x)\n\nquicksort(array, 0, len(array) - 1)\n\nprint(\"\\nQuicksorted array:\", end=' ')\nfor i in array:\n\tprint(i, end=' ')",
      "comments": {
        "1": "# Python program for implementing Quicksorting on a given array (start element is the pivot) method",
        "2": "# lb ~ Lower bound, ub ~ Upper bound",
        "5": "# minimum 2 distinct elements",
        "14": "# pivot element will be the first element of the array / sub-array",
        "16": "# * start and end will change throughout the function but lb and ub will stay the same",
        "19": "# ! first condition to prevent 'out of bounds' index for the last pass",
        "29": "# to prevent self swapping, none 1 element sub-array case",
        "32": "# * end is the 'indexer' to the pivot element placed at it's sorted position"
      },
      "OP_ss_dir": "OP_ss/QuickSort.py"
    }
  },
  "Sem_IV-SF": {
    "Bankers_Algorithm.py": {
      "lang": "py",
      "code_string_literal": "from os import system\nfrom prettytable import PrettyTable\n\ndef take_input():\n  machine_instances = [int(i) for i in input(\"Enter the machine instances: \").split()]\n  noofprocesses = int(input(\"Enter the No. of processes: \"))\n  allocations = []\n  max_needs = []\n\n  for i in range(0, noofprocesses):\n    print(f\"\\nFor Process P{i + 1}: \")\n    temp = [int(x) for x in input(\"Enter Allocation instances: \").split()][:len(machine_instances)] #\n    allocations.append(temp)\n\n    temp = [int(x) for x in input(\"Enter Max Need instances: \").split()][:len(machine_instances)]\n    max_needs.append(temp)\n\n  return machine_instances, allocations, max_needs\n\ndef calculate_available_inst_1(machine_instances, allocations):\n  sumof_allocations = []\n  col_sum = 0\n  \n  for i in range(0, len(machine_instances)):\n    for j in range(0, len(allocations)):\n      col_sum += allocations[j][i]\n    sumof_allocations.append(col_sum)\n    col_sum = 0\n  \n  return ([k - l for k, l in zip(machine_instances, sumof_allocations)])\n\ndef calculate_remaining_needs(max_needs, allocations):\n  remaining_needs = []\n  \n  for i, j in zip(max_needs, allocations):\n    indv_remaining_needs = [k - l for k, l in zip(i, j)]\n    remaining_needs.append(indv_remaining_needs)\n  \n  return remaining_needs\n\ndef table_print(allocations, max_needs, remaining_needs):\n  noofprocesses = len(max_needs)\n  Table = PrettyTable([\"Process No\", \"Allocation\", \"Max\", \"Remaining\"])\n  \n  for i in range(noofprocesses):\n    allocations_str = \"\"\n    for c in allocations[i]:\n      allocations_str += (str(c) + \" \")\n    \n    max_needs_str = \"\"\n    for c in max_needs[i]:\n      max_needs_str += (str(c) + \" \")\n    \n    remaining_needs_str = \"\"\n    for c in remaining_needs[i]:\n      remaining_needs_str += (str(c) + \" \")\n    \n    Table.add_row([i + 1, allocations_str, max_needs_str, remaining_needs_str])\n  \n  return Table\n\ndef bankers_algorithm():\n  system(\"cls\")\n  machine_instances, allocations, max_needs = take_input()\n  remaining_needs = calculate_remaining_needs(max_needs, allocations)\n  available = []\n  available.append(calculate_available_inst_1(machine_instances, allocations))\n  noofprocesses = len(max_needs)\n  \n  Table = table_print(allocations, max_needs, remaining_needs)\n  print(\"\\033[1m\\033[4m\\033[38;5;177mGiven Information:\\033[0m\\n\")\n  print(Table)\n  print(\"Initial available resources: \", available[0])\n\n  i = 0\n  j = 0\n  deadlock = 0\n  scheduled = 0\n  prev_cycle_scheduled = 0\n  schd_list = []\n  is_completed = [False for i in allocations]\n\n  while(deadlock != 1 and (scheduled != noofprocesses)): #\n    if(is_completed[i] == False):\n      pa = allocations[i]\n      rn = remaining_needs[i]\n      av = available[j]\n      can_fulfill = True\n\n      for m, n in zip(rn, av):\n        if m > n:\n          can_fulfill = False\n      \n      if(can_fulfill == True):\n        available.append((lambda a, b: [k + l for k, l in zip(a, b)])(pa, av)) #\n        j += 1\n        is_completed[i] = True\n        scheduled += 1\n        schd_list.append(i + 1)\n\n    i += 1    \n    if(i == noofprocesses):  \n      if(prev_cycle_scheduled == scheduled):\n        deadlock = 1\n      else:\n        prev_cycle_scheduled = scheduled\n        i = 0\n  \n  if deadlock == 1:\n    print(\"\\n\\033[1m\\033[38;5;196mDeadlock Occurred! The system is in an unsafe state!\\033[0m\")\n  else:\n    print(\"\\n\\033[1m\\033[38;5;158mThe system is in a safe state!\\n\\033[38;5;225m\\033[4mSafe sequence:\\033[0m\")\n    for i in schd_list:\n      if i != schd_list[-1]:\n        print(\"P\" + str(i) + \"\\033[38;5;216m \u2b9e \\033[0m\", end = \"\")\n      else:\n        print(\"P\" + str(i))\n\nbankers_algorithm()",
      "comments": {
        "12": "#! slicing done to prevent overfilling",
        "83": "#* while it is not a deadlock and not all processes have been scheduled",
        "95": "#* returns a list which has the sum of individual elements of pa and av"
      },
      "OP_ss_dir": "OP_ss/Bankers_Algorithm.py"
    },
    "Booths_Algorithm.py": {
      "lang": "py",
      "code_string_literal": "from prettytable import PrettyTable\nfrom os import system\nsystem(\"cls\")\n\ndef take_input():\n  mcand = int(input(\"Enter the Multiplicand: \"))\n  mlier = int(input(\"Enter the Multiplier: \"))\n\n  return mcand, mlier\n\ndef to_binary(*dec_number):\n  bin_master_list = []\n\n  def mechanism(dec_number):\n    if (dec_number >= 1):\n      mechanism(dec_number // 2)\n      bin_num.append(dec_number % 2)\n\n  for i in dec_number:\n    bin_num = []\n    mechanism(i)\n    bin_master_list.append(bin_num)\n\n  return bin_master_list\n\ndef dynamic_bit_adjuster(list1, list2):\n  l1 = len(list1)\n  l2 = len(list2)\n\n  if (l1 != l2):\n    if (l1 > l2):\n      list1.insert(0, 0)\n      for i in range(l2, l1 + 1):\n        list2.insert(0, 0)\n\n    elif (l2 > l1):\n      list2.insert(0, 0)\n      for i in range(l1, l2 + 1):\n        list1.insert(0, 0)\n  else:\n    list1.insert(0, 0)\n    list2.insert(0, 0)\n\n\ndef ones_complement(binary_num_list):\n  for i in range(0, len(binary_num_list)):\n    if binary_num_list[i] == 0:\n      binary_num_list[i] = 1\n    else:\n      binary_num_list[i] = 0\n\ndef binary_add(list1, list2):\n  carry = 0\n\n  for i in range(len(list1) - 1, -1, -1):  #\n    if (carry == 0):\n      if (list1[i] == 0 and list2[i] == 0):\n        list1[i] = 0\n      elif (list1[i] == 0 and list2[i] == 1):\n        list1[i] = 1\n      elif (list1[i] == 1 and list2[i] == 0):\n        list1[i] = 1\n      elif (list1[i] == 1 and list2[i] == 1):\n        list1[i] = 0\n        carry = 1  #\n\n    elif (carry == 1):\n      if (list1[i] == 0 and list2[i] == 0):\n        list1[i] = 1\n        carry = 0\n\n      elif (list1[i] == 0 and list2[i] == 1):\n        list1[i] = 0\n        carry = 1\n\n      elif (list1[i] == 1 and list2[i] == 0):\n        list1[i] = 0\n        carry = 1\n\n      elif (list1[1] == 1 and list2[i] == 1):\n        list1[i] = 1\n        carry = 1  #\n\ndef twos_complement(list1):\n  one = [1]\n  for i in range(0, len(list1)-1):\n    one.insert(0, 0)\n\n  ones_complement(list1)\n  binary_add(list1, one)\n\ndef ar_right_shift(list1, list2):\n  temp_bit1 = list1[-1]\n  temp_bit2 = list2[-1]  #\n  temp_copy1 = list1.copy()\n  temp_copy2 = list2.copy()\n\n  for i in range(1, len(list1)):\n    list1[i] = temp_copy1[i - 1]\n    list2[i] = temp_copy2[i - 1]\n  list2[0] = temp_bit1\n\n  return temp_bit2\n\ndef list_to_string(list1):\n  string = \"\"\n  for i in list1:\n    string += str(i)\n\n  return string\n\ndef to_decimal(list1, list2, dec_mcand, dec_mlier):\n  list3 = list1 + list2\n  expo = 0\n  summation = 0\n\n  if ((dec_mcand < 0 and dec_mlier > 0) or (dec_mlier < 0 and dec_mcand > 0)):\n    twos_complement(list3)\n\n  for i in range(len(list3)-1, -1, -1):\n    if (list3[i] == 1):\n      summation += 2**(expo)\n    expo += 1\n\n  return summation\n\ndef Booths_Algorithm():\n  #\n  dec_mcand, dec_mlier = take_input()\n\n  #\n  if dec_mcand == 0 or dec_mlier == 0:\n    print(\"Final Answer\\n{} x {} = {}\".format(dec_mcand, dec_mlier, 0))\n    return 0\n\n  #\n  bin_nums = to_binary(abs(dec_mcand), abs(dec_mlier))\n  bin_mcand = bin_nums[0]\n  bin_mlier = bin_nums[1]\n\n  #\n  dynamic_bit_adjuster(bin_mcand, bin_mlier)\n\n  #\n  if (dec_mcand < 0):\n    twos_complement(bin_mcand)\n  if (dec_mlier < 0):\n    twos_complement(bin_mlier)\n\n  #\n  A = [0 for i in range(0, len(bin_mcand))]\n  Q = bin_mlier.copy()\n  M = bin_mcand.copy()\n  twos_complement(bin_mcand)  #\n  m_M = bin_mcand.copy()\n  Qm1 = 0  #\n  count = len(bin_mcand)\n  table = PrettyTable([\"A\", \"Q\", \"Q_-1\", \"Count\", \"Operation\"])\n  final_table = [[list_to_string(A), list_to_string(Q), Qm1, count, \"Start\"]]\n\n  while (count > 0):\n    if (Q[-1] == 1 and Qm1 == 0):\n      binary_add(A, m_M)\n      #\n      final_table.append(\n        [list_to_string(A), list_to_string(Q), Qm1, count, \"A = A - M\"])\n\n    elif (Q[-1] == 0 and Qm1 == 1):\n      binary_add(A, M)\n      final_table.append(\n        [list_to_string(A), list_to_string(Q), Qm1, count, \"A = A + M\"])\n\n    Qm1 = ar_right_shift(A, Q)\n    final_table.append([list_to_string(A), list_to_string(\n      Q), Qm1, count, \"Arithmetic Right Shift\"])\n    count -= 1\n\n  #\n  final_table.append(['', '', '', '', \"Finish\"])\n  table.add_rows(final_table)\n  print(table)\n\n  #\n  f_a = to_decimal(A, Q, dec_mcand, dec_mlier)\n  if ((dec_mcand < 0 and dec_mlier > 0) or (dec_mlier < 0 and dec_mcand > 0)):\n    print(\"\\nFinal Answer:\\n{} x {} = -{}\".format(dec_mcand, dec_mlier, f_a))\n  else:\n    print(\"\\nFinal Answer:\\n{} x {} = {}\".format(dec_mcand, dec_mlier, f_a))\n\n\nBooths_Algorithm()\n",
      "comments": {
        "55": "# reverse traversal",
        "65": "# ! Quite important",
        "82": "# ! Quite important",
        "94": "# last bits",
        "128": "# taking input",
        "131": "# check for input 0",
        "136": "# coversion from decimal to binary for both inputs",
        "141": "# adjusting bits for both multiplicand and multiplier",
        "144": "# taking twos-complement if negative",
        "150": "# preparation for the main algorithm",
        "154": "# this WILL change bin_mcand",
        "156": "# Q_minus_1 bit",
        "164": "# have to convert to string to mitigate reference assignment of modified list",
        "178": "# printing the Operations table",
        "183": "# printing the final answer"
      },
      "OP_ss_dir": "OP_ss/Booths_Algorithm.py"
    },
    "Disk_Scheduling.py": {
      "lang": "py",
      "code_string_literal": "import numpy as np\nfrom os import system\n\ndef take_input():\n  req_sequence = [int(i) for i in input(\"Enter the request sequence: \").split()]\n  initial_rest = int(input(\"Enter the initial resting of the head: \"))\n  seek_multiplier = int(input(\"Enter the cost for travelling a single track: \"))\n  total_nooftracks = int(input(\"Enter the total number of tracks available: \"))\n\n  return req_sequence, initial_rest, seek_multiplier, total_nooftracks\n\ndef final_ans(total_seek_time, disk_schedule, initial_rest, algo_name):\n  print(\"\\033[1m\\033[4m\\033[38;5;229m\" + str(algo_name) + \"\\033[0m\")\n  print(\"\\033[1m\\033[38;5;85mDisk Pointer Trace: \\033[0m\")\n  print(\"\\033[1m\\033[38;5;213m\"+ str(initial_rest) + \"\\033[0m -> \", end = \"\")\n  for i in disk_schedule:\n    if i != disk_schedule[-1]:\n      print(i, \"-> \", end = \"\")\n    else:\n      print(i)\n  \n  print(\"Total Seek Time: \\033[1m\\033[4m\\033[38;5;217m\"+ str(total_seek_time) + \"\\033[0m msecs\\n\\n\")\n\ndef fcfs_dschd(req_sequence, curr_rest, per_track_seek_cost, total_nooftracks = 200):\n  initial_rest = curr_rest\n  total_seek_time = 0\n  disk_schedule = []\n\n  for i in req_sequence:\n    disk_schedule.append(i)\n    total_seek_time += np.abs(i - curr_rest) * per_track_seek_cost\n    curr_rest = i \n\n  final_ans(total_seek_time, disk_schedule, initial_rest, \"First Come First Serve (FCFS)\")\n\ndef sstf_dschd(req_sequence, curr_rest, per_track_seek_cost, total_nooftracks = 200):\n  initial_rest = curr_rest\n  total_seek_time = 0\n  nooftracks = len(req_sequence)\n  min_cost = 9999\n  to_schd = -1\n  temp_cost = 0\n  disk_schedule = []\n\n  while len(disk_schedule) != nooftracks:\n    for i in req_sequence:\n      temp_cost = np.abs(i - curr_rest) * per_track_seek_cost\n      if temp_cost < min_cost:\n        min_cost = temp_cost\n        to_schd = i\n        \n    req_sequence.remove(to_schd)\n    total_seek_time += min_cost\n    min_cost = 9999\n    disk_schedule.append(to_schd)\n    curr_rest = to_schd\n\n  final_ans(total_seek_time, disk_schedule, initial_rest, \"Shortest Seek Time First (SSTF)\")\n\ndef scan_dschd(req_sequence, curr_rest, per_track_seek_cost, total_nooftracks = 200):\n  initial_rest = curr_rest\n  total_seek_time = 0\n  disk_schedule = []\n  \n  sorted_req_sequence = list(sorted(req_sequence))\n  left_tracks = [i for i in sorted_req_sequence if i < curr_rest]\n  right_tracks = [i for i in sorted_req_sequence if i > curr_rest]\n  \n  #\n  diff_1 = curr_rest - 0\n  diff_2 = (total_nooftracks - 1) - curr_rest\n  \n  if(diff_1 <= diff_2):\n    left_tracks.insert(0, 0)\n    for i in range(len(left_tracks) - 1, -1, -1): #\n      disk_schedule.append(left_tracks[i])\n      total_seek_time += (curr_rest - left_tracks[i]) * per_track_seek_cost\n      curr_rest = left_tracks[i]\n\n    for i in range(0, len(right_tracks)):         #\n      disk_schedule.append(right_tracks[i])\n      total_seek_time += (right_tracks[i] - curr_rest) * per_track_seek_cost\n      curr_rest = right_tracks[i]\n  \n  else:\n    right_tracks.append(total_nooftracks - 1)\n    for i in range(0, len(right_tracks)):         #\n      disk_schedule.append(right_tracks[i])\n      total_seek_time += (right_tracks[i] - curr_rest) * per_track_seek_cost\n      curr_rest = right_tracks[i]\n\n    for i in range(len(left_tracks) - 1, -1, -1):   #\n      disk_schedule.append(left_tracks[i])\n      total_seek_time += (curr_rest - left_tracks[i]) * per_track_seek_cost\n      curr_rest = left_tracks[i]\n\n  final_ans(total_seek_time, disk_schedule, initial_rest, \"SCAN\")\n\ndef cscan_dschd(req_sequence, curr_rest, per_track_seek_cost, total_nooftracks = 200):\n  initial_rest = curr_rest\n  total_seek_time = 0\n  disk_schedule = []\n  \n  sorted_req_sequence = list(sorted(req_sequence))\n  left_tracks = [i for i in sorted_req_sequence if i < curr_rest]\n  right_tracks = [i for i in sorted_req_sequence if i > curr_rest]\n  \n  #\n  diff_1 = curr_rest - 0\n  diff_2 = (total_nooftracks - 1) - curr_rest\n\n  if(diff_1 <= diff_2): #\n    left_tracks.insert(0, 0)\n    for i in range(len(left_tracks) - 1, -1, -1):           #\n      disk_schedule.append(left_tracks[i])\n      total_seek_time += np.abs(curr_rest - left_tracks[i]) * per_track_seek_cost\n      curr_rest = left_tracks[i]\n\n    curr_rest = total_nooftracks - 1                       #\n    for i in range(len(right_tracks) - 1, -1, -1):         #\n      disk_schedule.append(right_tracks[i])\n      total_seek_time += np.abs(right_tracks[i] - curr_rest) * per_track_seek_cost\n      curr_rest = right_tracks[i]\n  \n  else: #\n    right_tracks.append(total_nooftracks - 1)\n    for i in range(0, len(right_tracks)):         #\n      disk_schedule.append(right_tracks[i])\n      total_seek_time += np.abs(right_tracks[i] - curr_rest) * per_track_seek_cost\n      curr_rest = right_tracks[i]\n    \n    curr_rest = 0                                       #\n    for i in range(0, len(left_tracks)):         #\n      disk_schedule.append(left_tracks[i])\n      total_seek_time += np.abs(curr_rest - left_tracks[i]) * per_track_seek_cost\n      curr_rest = left_tracks[i]\n\n  final_ans(total_seek_time, disk_schedule, initial_rest, \"C-SCAN\")\n\ndef look_dschd(req_sequence, curr_rest, per_track_seek_cost, total_nooftracks = 200):\n  initial_rest = curr_rest\n  total_seek_time = 0\n  disk_schedule = []\n  \n  sorted_req_sequence = list(sorted(req_sequence))\n  left_tracks = [i for i in sorted_req_sequence if i < curr_rest]\n  right_tracks = [i for i in sorted_req_sequence if i > curr_rest]\n  \n  #\n  diff_1 = curr_rest - 0\n  diff_2 = (total_nooftracks - 1) - curr_rest\n  \n  if(diff_1 <= diff_2):\n    for i in range(len(left_tracks) - 1, -1, -1): #\n      disk_schedule.append(left_tracks[i])\n      total_seek_time += (curr_rest - left_tracks[i]) * per_track_seek_cost\n      curr_rest = left_tracks[i]\n\n    for i in range(0, len(right_tracks)):         #\n      disk_schedule.append(right_tracks[i])\n      total_seek_time += (right_tracks[i] - curr_rest) * per_track_seek_cost\n      curr_rest = right_tracks[i]\n  \n  else:\n    for i in range(0, len(right_tracks)):         #\n      disk_schedule.append(right_tracks[i])\n      total_seek_time += (right_tracks[i] - curr_rest) * per_track_seek_cost\n      curr_rest = right_tracks[i]\n\n    for i in range(len(left_tracks) - 1, -1, -1):   #\n      disk_schedule.append(left_tracks[i])\n      total_seek_time += (curr_rest - left_tracks[i]) * per_track_seek_cost\n      curr_rest = left_tracks[i]\n\n  final_ans(total_seek_time, disk_schedule, initial_rest, \"LOOK\")\n\ndef clook_dschd(req_sequence, curr_rest, per_track_seek_cost, total_nooftracks = 200):\n  initial_rest = curr_rest\n  total_seek_time = 0\n  disk_schedule = []\n  \n  sorted_req_sequence = list(sorted(req_sequence))\n  left_tracks = [i for i in sorted_req_sequence if i < curr_rest]\n  right_tracks = [i for i in sorted_req_sequence if i > curr_rest]\n  \n  #\n  diff_1 = curr_rest - 0\n  diff_2 = (total_nooftracks - 1) - curr_rest\n\n  if(diff_1 <= diff_2): #\n    for i in range(len(left_tracks) - 1, -1, -1):           #\n      disk_schedule.append(left_tracks[i])\n      total_seek_time += np.abs(curr_rest - left_tracks[i]) * per_track_seek_cost\n      curr_rest = left_tracks[i]\n\n    curr_rest = right_tracks[-1]               #\n    for i in range(len(right_tracks) - 1, -1, -1):         #\n      disk_schedule.append(right_tracks[i])\n      total_seek_time += np.abs(right_tracks[i] - curr_rest) * per_track_seek_cost\n      curr_rest = right_tracks[i]\n\n  else: #\n    for i in range(0, len(right_tracks)):         #\n      disk_schedule.append(right_tracks[i])\n      total_seek_time += np.abs(right_tracks[i] - curr_rest) * per_track_seek_cost\n      curr_rest = right_tracks[i]\n    \n    curr_rest = left_tracks[0]                  #\n    for i in range(0, len(left_tracks)):   #\n      disk_schedule.append(left_tracks[i])\n      total_seek_time += np.abs(curr_rest - left_tracks[i]) * per_track_seek_cost\n      curr_rest = left_tracks[i]\n\n  final_ans(total_seek_time, disk_schedule, initial_rest, \"C-LOOK\")\n\ndef caller():\n  system(\"cls\")\n  req_sequence, initial_rest, seek_multiplier, total_nooftracks = take_input()\n  backup_req_sequence = list(req_sequence)\n  print(\"\\n\\033[1m\\033[38;5;183mThis program chooses the direction of scheduling by determining the nearest end from the initial resting and going towards the nearer one.\\nAlso, in C-SCAN and C-LOOK, this program is not counting the end-to-end track change.\\n\\033[0m\")\n  algorithms = {\"1\": fcfs_dschd, \"2\": sstf_dschd, \"3\": scan_dschd, \"4\": cscan_dschd, \"5\": look_dschd, \"6\":clook_dschd}\n  for i in algorithms:\n      algorithms[i](req_sequence, initial_rest, seek_multiplier, total_nooftracks)\n      req_sequence = list(backup_req_sequence)\n\ncaller()",
      "comments": {
        "69": "#* to choose side, nearest end is chosen",
        "75": "#? reverse traversing the left tracks first",
        "80": "#? then go for the right tracks ascendingly",
        "87": "#* go for the right tracks first ascendingly",
        "92": "#* then go for the left tracks descendingly",
        "108": "#* to choose side, nearest end is chosen",
        "112": "#! left side",
        "114": "#? reverse traversing the left tracks first",
        "119": "#! Do not penalize for ends-change step",
        "120": "#? then go for the right tracks also reverse",
        "125": "#! right side",
        "127": "#* go for the right tracks first ascendingly",
        "132": "#! Do not penalize for ends-change step",
        "133": "#* then go for the left tracks also ascendingly",
        "149": "#* to choose side, nearest end is chosen",
        "154": "#? reverse traversing the left tracks first",
        "159": "#? then go for the right tracks ascendingly",
        "165": "#* go for the right tracks first ascendingly",
        "170": "#* then go for the left tracks descendingly",
        "186": "#* to choose side, nearest end is chosen",
        "190": "#! left side",
        "191": "#? reverse traversing the left tracks first",
        "196": "#! Do not penalize (or penalize less (alpha)) for ends-change step, also end is not the last track but the last requested track",
        "197": "#? then go for the right tracks also reverse",
        "202": "#! right side",
        "203": "#* go for the right tracks first ascendingly",
        "208": "#!",
        "209": "#* then go for the left tracks also ascendingly"
      },
      "OP_ss_dir": "OP_ss/Disk_Scheduling.py"
    },
    "Fixed_Memory_Placement(Static).py": {
      "lang": "py",
      "code_string_literal": "from os import system\ndef take_input():\n  memory = [[int(i), 0, 0, False] for i in input(\"Enter memory block sizes: \").split()]\n  processes = [[int(i), False] for i in input(\"Enter processes' sizes: \").split()]\n\n  return memory, processes\n\ndef print_memory(memory, processes):\n  print(\"============================ Main Memory =============================\\nBlock No.\\tBlock Size\\tFilled Process\\tInternal Fragmentation\")\n  for block in memory:\n    if(block[3] == True):\n      print(\"  {}\\t        \\033[1;32m   {}\\t\\t   {}\\t\\t    {}\\033[0m\".format((memory.index(block) + 1), block[0], block[1], block[2]))\n    elif(block[3] == -1 or block[3] == False):\n      print(\"  {}\\t        \\033[1;31m   {}\\t\\t   {}\\t\\t    {}\\033[0m\".format((memory.index(block) + 1), block[0], block[1], block[2]))\n\n  print(\"Total Internal Fragmentation (Memory Loss) incurred: \\033[1;31m\", sum(i[2] for i in memory), \"kB\\033[0m\")\n\n  print(\"Unassigned processes: \", end = \" \")\n  unassigned = [i for i in processes if i[1] == False]\n  for i in unassigned:\n    print(str(i[0]) + \" kB\", end = \" \")\n\ndef reset(memory, processes):\n  for block in memory:\n    block[1] = 0\n    block[2] = 0\n    block[3] = False\n\n  for process in processes:\n    process[1] = False\n\ndef first_fit(memory, processes):\n  for process in processes:\n    for block in memory:\n      if block[0] >= process[0] and block[3] == False:\n        block[1] = process[0]                   #\n        block[2] = block[0] - process[0]        #\n        block[3] = True                         #\n        process[1] = True\n        break\n  print(\"\\033[1;34m After applying First-Fit\\033[0m\")\n  print_memory(memory, processes)\n\ndef best_fit(memory, processes):\n  wastages = []\n\n  for process in processes:\n    for block in memory:\n      if block[0] >= process[0] and block[3] == False:\n        wastages.append(block[0] - process[0])\n\n    if len(wastages) != 0:    \n      least_waste = min(wastages)\n      for block in memory:\n        if block[0] - process[0] == least_waste:\n          block[1] = process[0]              \n          block[2] = block[0] - process[0]        \n          block[3] = True                       \n          process[1] = True\n          break\n\n    wastages = []\n  print(\"\\033[1;34m After applying Best-Fit\\033[0m\")\n  print_memory(memory, processes)\n\ndef worst_fit(memory, processes):\n  wastages = []\n\n  for process in processes:\n    for block in memory:\n      if block[0] >= process[0] and block[3] == False:\n        wastages.append(block[0] - process[0])\n\n    if len(wastages) != 0:    \n      max_waste = max(wastages)\n      for block in memory:\n        if block[0] - process[0] == max_waste:\n          block[1] = process[0]              \n          block[2] = block[0] - process[0]        \n          block[3] = True                       \n          process[1] = True\n          break\n\n    wastages = []    \n  print(\"\\033[1;34m After applying Worst-Fit\\033[0m\")\n  print_memory(memory, processes)\n\ndef switch_case(memory, processes):\n  fit_choices = {\"1\": first_fit, \"2\": best_fit, \"3\": worst_fit}\n  choice = input(\"\\n1. First-Fit\\n2. Best-Fit\\n3. Worst-Fit: \")\n  fit_choices[choice](memory, processes)\n\ndef fit_again(memory, processes):\n  choice = int(input(\"\\n\\nTry another Fit?\\n(0. No, 1. Yes): \"))\n  if choice == 1:\n    choice2 = int(input(\"With new processes?\\n(0. No, 1. Yes): \"))\n    if choice2 == 1:\n      caller()\n    else:\n      reset(memory, processes)\n      switch_case(memory, processes)\n      fit_again(memory, processes)\n\ndef caller():\n  system(\"cls\")\n  memory, processes = take_input()\n  switch_case(memory, processes)\n  fit_again(memory, processes) \n\ncaller()",
      "comments": {
        "36": "#actually what is filled in the block",
        "37": "#what is the wastage",
        "38": "#status_check = True, this block cannot be used again?"
      },
      "OP_ss_dir": "OP_ss/Fixed_Memory_Placement(Static).py"
    },
    "Memory_Page_Replacement.py": {
      "lang": "py",
      "code_string_literal": "from os import system\n\ndef take_input():\n  ref_string = [int(i) for i in input(\"Enter the Reference String: \").split()]\n  memory = [-1 for i in range(0, int(input(\"Enter the no. of frames in the memory: \")))]\n\n  return ref_string, memory\n\ndef fifo_page_rpmt(ref_string, memory):\n  faults = 0\n  hits = 0\n  to_place_index = 0\n  flag = 0\n  noofrefs = len(ref_string)\n  noofframes = len(memory)\n  print(\"\\n\")\n\n  for ref in ref_string:\n    for frame in memory:\n      if(frame == ref):\n        hits += 1\n        flag = 1\n    \n    if(flag == 0):\n      faults += 1\n      memory[to_place_index] = ref\n      to_place_index = (to_place_index + 1) % (noofframes)\n    flag = 0                    \n    print(\"| Reference: \\033[1m\\033[38;5;117m{}\\033[0m | Current Memory: {} | Fault count: \\033[1m\\033[38;5;196m{}\\033[0m | Hit count: \\033[1m\\033[38;5;156m{}\\033[0m\".format(ref, memory, faults, hits))\n  \n  print(\"\\n\\033[1m\\033[4m\\033[38;5;122mResults\\033[0m\")\n  print(f\"No. of Hits: \\033[38;5;156m{hits}\\033[0m\\nNo. of Faults(Miss): \\033[38;5;196m{faults}\\033[0m\\nHit Ratio: \\033[38;5;156m{hits}/{noofrefs}\\033[0m\\nFault(Miss) Ratio: \\033[38;5;196m{faults}/{noofrefs}\\033[0m\\n\")\n\ndef lru_page_rpmt(ref_string, memory):\n  faults = 0\n  hits = 0\n  to_place_index = 0\n  flag = 0\n  noofrefs = len(ref_string)\n  page_in_frame_age = [(i + 996) for i in range(len(memory)-1, -1, -1)]\n  print(\"\\n\")\n\n  for ref in ref_string:\n    for frame in memory:\n      if(frame == ref):\n        hits += 1\n        page_in_frame_age[memory.index(ref)] = 0        #\n        flag = 1\n\n    if(flag == 0):\n      faults += 1\n      to_place_index = page_in_frame_age.index(max(page_in_frame_age))\n      page_in_frame_age[to_place_index] = 0 \n      memory[to_place_index] = ref\n    flag = 0    \n    page_in_frame_age = list(map(lambda x: x + 1, page_in_frame_age)) #\n    print(\"| Reference: \\033[1m\\033[38;5;117m{}\\033[0m | Current Memory: {} | Fault count: \\033[1m\\033[38;5;196m{}\\033[0m | Hit count: \\033[1m\\033[38;5;156m{}\\033[0m\".format(ref, memory, faults, hits))\n\n  print(\"\\n\\033[1m\\033[4m\\033[38;5;122mResults\\033[0m\")\n  print(f\"No. of Hits: \\033[38;5;156m{hits}\\033[0m\\nNo. of Faults(Miss): \\033[38;5;196m{faults}\\033[0m\\nHit Ratio: \\033[38;5;156m{hits}/{noofrefs}\\033[0m\\nFault(Miss) Ratio: \\033[38;5;196m{faults}/{noofrefs}\\033[0m\\n\")\n\ndef optimal_page_rpmt(ref_string, memory):\n  faults = 0\n  hits = 0\n  to_place_index = 0\n  flag = 0\n  noofrefs = len(ref_string)\n  curr_pages_in_frames_future = [-1 for i in memory]\n  \n  def find_future_occurence():\n    for i in range(0, len(memory)):\n      try:\n        curr_pages_in_frames_future[i] = ref_string[curr_index:].index(memory[i])\n      except ValueError:                          #\n        curr_pages_in_frames_future[i] = 999\n  \n  curr_index = 0    #\n  for ref in ref_string:\n    for frame in memory:\n      if(frame == ref):\n        hits += 1\n        flag = 1\n\n    if(flag == 0):\n      faults += 1\n      find_future_occurence()\n      to_place_index = curr_pages_in_frames_future.index(max(curr_pages_in_frames_future))\n      memory[to_place_index] = ref\n    flag = 0\n    curr_index += 1\n    \n    print(\"| Reference: \\033[1m\\033[38;5;117m{}\\033[0m | Current Memory: {} | Fault count: \\033[1m\\033[38;5;196m{}\\033[0m | Hit count: \\033[1m\\033[38;5;156m{}\\033[0m\".format(ref, memory, faults, hits))\n\n  print(\"\\n\\033[1m\\033[4m\\033[38;5;122mResults\\033[0m\")\n  print(f\"No. of Hits: \\033[38;5;156m{hits}\\033[0m\\nNo. of Faults(Miss): \\033[38;5;196m{faults}\\033[0m\\nHit Ratio: \\033[38;5;156m{hits}/{noofrefs}\\033[0m\\nFault(Miss) Ratio: \\033[38;5;196m{faults}/{noofrefs}\\033[0m\\n\")\n\ndef caller():\n  system(\"cls\")\n  ref_string, memory = take_input()\n  algorithms = {1: fifo_page_rpmt, 2: lru_page_rpmt, 3: optimal_page_rpmt}\n  algorithms[int(input(\"Enter the algorithm to be used:\\n1. FIFO\\n2. LRU\\n3. Optimal: \"))](ref_string, memory) #\n\ncaller()",
      "comments": {
        "47": "#! resetting age, when hit",
        "56": "#! incrementing all pages in frame's age at the end of each iteration",
        "74": "#there is no future occurence of page in frame in memory[i], highest priority to replace",
        "77": "#simpler to control the for-in loop in this case",
        "101": "#! calling a value of the dictionary which is a function hence parameters are also passed here"
      },
      "OP_ss_dir": "OP_ss/Memory_Page_Replacement.py"
    },
    "Non_Preemptive_Task_Scheduling.py": {
      "lang": "py",
      "code_string_literal": "from os import system\nimport numpy as np\nimport pandas as pd\n\ndef take_input():\n  data = []\n  no_of_process = int(input(\"Enter the number of processes: \"))\n  if no_of_process <= 0:\n    print(\"Exiting...\")\n    exit()\n\n  for i in range(1, no_of_process + 1):\n    arr_time = int(\n      input(\"Enter the Arrival Time for Process {}: \".format(i)))\n    burst_time = int(\n      input(\"Enter the Burst Time for Process {}: \".format(i)))\n    priority = int(input(\"Enter the Priority for Process {}: \".format(i)))\n    temp_dict = {'Process No.': i, 'Arrival Time': arr_time,\n                  'Burst Time': burst_time, 'Priority': priority}\n    data.append(temp_dict)\n\n  schd_type = int(\n    input(\"Enter the type of Scheduling Algorithm:\\n1. FCFS\\n2. SJF\\nChoice: \"))\n\n  return data, schd_type\n\ndef sort_df(data_frame, by_parameter):\n  sorted_df = data_frame.sort_values(by=by_parameter)\n  #\n  sorted_df.reset_index(inplace=True, drop=True)\n  return sorted_df\n\ndef sorted_process_list(sorted_df):\n  process_list = []\n\n  for i in range(0, len(sorted_df)):\n    process_list.append([sorted_df['Process No.'][i], sorted_df['Arrival Time']\n                          [i], sorted_df['Burst Time'][i], sorted_df['Priority'][i]])\n\n  return process_list\n\ndef redone_gantt_chart(sorted_schd_list, passed_time=0):\n  end_times = []\n  gantt_list = []\n  passed_time = 0\n\n  def redone_match_ATPT(curr_passed_time, next_arr_time):\n    if curr_passed_time < next_arr_time:\n      if curr_passed_time == 0:\n        gantt_list.extend([curr_passed_time, \"idle\", next_arr_time])\n      else:\n        gantt_list.extend(['idle', next_arr_time])\n      return next_arr_time\n    elif curr_passed_time == 0:\n      gantt_list.append(curr_passed_time)\n    return curr_passed_time\n\n  for i in sorted_schd_list:\n    passed_time = redone_match_ATPT(passed_time, i[1])\n    passed_time += i[2]\n    gantt_list.extend(['P' + str(i[0]), passed_time])\n    end_times.append(passed_time)\n\n  def print_gantt(gantt_list):\n    for i in gantt_list:\n        if i != gantt_list[-1]:\n          print(i, \"-> \", end=\"\")\n        else:\n          print(i)\n  print_gantt(gantt_list)\n\n  return end_times\n\ndef turnaround_time(sorted_df):\n  indv_TAT = []\n\n  for i in range(0, len(sorted_df)):\n    pFT = sorted_df[\"Finish Time\"][i]\n    aT = sorted_df[\"Arrival Time\"][i]\n    indv_TAT.append(pFT - aT)\n\n  avg_TAT = np.average(indv_TAT)\n  sorted_df[\"Turnaround Time\"] = indv_TAT\n  return avg_TAT, sorted_df\n\ndef waiting_time(sorted_df):\n  indv_WT = []  #\n\n  #\n  for i in range(0, len(sorted_df)):\n    TAT = sorted_df[\"Turnaround Time\"][i]\n    BT = sorted_df[\"Burst Time\"][i]\n    indv_WT.append(TAT - BT)\n\n  avg_WT = np.average(indv_WT)\n  sorted_df[\"Waiting Time\"] = indv_WT\n  return avg_WT, sorted_df\n\ndef fcfs(raw_df):\n  sorted_df = sort_df(raw_df, 'Arrival Time')\n  sorted_schd_list = sorted_process_list(sorted_df)\n\n  print(\"\\nGantt Chart:\")\n  per_process_end_time = redone_gantt_chart(sorted_schd_list)\n  sorted_df[\"Finish Time\"] = per_process_end_time\n\n  avg_turnaround_time, sorted_df = turnaround_time(sorted_df)\n  avg_wait_time, sorted_df = waiting_time(sorted_df)\n  pd.set_option('display.expand_frame_repr', False)\n  print(\"\\nSchedule Table:\\n\", sorted_df)\n  print(\"\\nAverage Waiting Time: {}\\nAverage Turnaround Time: {}\\n\".format(\n    avg_wait_time, avg_turnaround_time))\n\ndef sjf_check_special_cases(raw_df):\n  if (len(raw_df[\"Arrival Time\"].unique()) == 1):\n    return 0\n  elif (len(raw_df[\"Burst Time\"].unique()) == 1):\n    return 1\n  return -1\n\ndef slice_df(sorted_df, sort_factor, curr_passed_time):\n  sliced_df = sorted_df.loc[sorted_df[sort_factor] <= curr_passed_time]\n\n  if len(sliced_df) == 0:\n    sliced_df = sorted_df.loc[sorted_df[sort_factor] > curr_passed_time]\n    first_greater_AT = sliced_df[\"Arrival Time\"].iloc[0]\n    sliced_df = sorted_df.loc[sorted_df[sort_factor] == first_greater_AT]\n\n  sliced_sorted_BT_df = sort_df(sliced_df, \"Burst Time\")\n  to_schd = list(sliced_sorted_BT_df.iloc[0])\n  sorted_df = sorted_df.drop(\n    sorted_df[sorted_df[\"Process No.\"] == to_schd[0]].index)\n\n  return to_schd, to_schd[2], sorted_df\n\ndef sjf(raw_df):\n  case = sjf_check_special_cases(raw_df)\n  fin_sorted_schd_list = []\n  curr_passed_time = 0\n\n  if case == 1:  #\n    fcfs(raw_df)\n  elif case == 0:  #\n    sorted_df = sort_df(raw_df, 'Burst Time')\n    sorted_schd_list = sorted_process_list(sorted_df)\n\n    print(\"\\nGantt Chart:\")\n    per_process_end_time = redone_gantt_chart(sorted_schd_list)\n    sorted_df[\"Finish Time\"] = per_process_end_time\n\n    avg_turnaround_time, sorted_df = turnaround_time(sorted_df)\n    avg_wait_time, sorted_df = waiting_time(sorted_df)\n    pd.set_option('display.expand_frame_repr', False)\n    print(\"\\nSchedule Table:\\n\", sorted_df)\n    print(\"Average Waiting Time: {}\\nAverage Turnaround Time: {}\".format(\n        avg_wait_time, avg_turnaround_time))\n  else:\n    initial_sorted_df = sort_df(raw_df, 'Arrival Time')\n    mod_sorted_df = initial_sorted_df.copy()\n    curr_passed_time = initial_sorted_df[\"Arrival Time\"][0]\n\n    for i in range(0, len(initial_sorted_df)):\n        temp_catcher, prev_burst, mod_sorted_df = slice_df(\n            mod_sorted_df, \"Arrival Time\", curr_passed_time)\n        curr_passed_time += prev_burst\n        fin_sorted_schd_list.append(temp_catcher)\n\n    process_order = [j[0] for j in fin_sorted_schd_list]\n    new_sorted_df = pd.DataFrame()\n    for i in range(0, len(process_order)):\n        new_sorted_df = pd.concat(\n            [new_sorted_df, initial_sorted_df[initial_sorted_df[\"Process No.\"] == process_order[i]]], ignore_index=True)\n\n    print(\"\\nGantt Chart:\")\n    per_process_end_time = redone_gantt_chart(fin_sorted_schd_list)\n    new_sorted_df[\"Finish Time\"] = per_process_end_time\n\n    avg_turnaround_time, new_sorted_df = turnaround_time(new_sorted_df)\n    avg_wait_time, new_sorted_df = waiting_time(new_sorted_df)\n    pd.set_option('display.expand_frame_repr', False)\n    print(\"\\nSchedule Table:\\n\", new_sorted_df)\n    print(\"\\nAverage Waiting Time: {}\\nAverage Turnaround Time: {}\\n\".format(\n        avg_wait_time, avg_turnaround_time))\n\ndef caller():\n  system(\"cls\")\n  data, schd_type = take_input()\n  data_frame = pd.DataFrame(data)\n  print(\"\\nRaw DataFrame:\\n\", data_frame)\n  if schd_type == 1:\n    fcfs(data_frame)\n  elif schd_type == 2:\n    sjf(data_frame)\n  else:\n    print(\"Invalid Choice!\")\n\ncaller()",
      "comments": {
        "29": "# ! necessary, otherwise process list function would give unsorted list since for-in loop goes by index",
        "87": "# in FCFS, the waiting time of the first process will be always 0",
        "89": "#! using formula WT = TAT - BT",
        "141": "# All burst times equal",
        "143": "# All arrival times equal"
      },
      "OP_ss_dir": "OP_ss/Non_Preemptive_Task_Scheduling.py"
    },
    "Non_Restoring_Division.py": {
      "lang": "py",
      "code_string_literal": "from prettytable import PrettyTable\n\ndef take_input():\n  dvnd = int(input(\"Enter the Dividend: \"))\n  dvsr = int(input(\"Enter the Divisor: \"))\n\n  return dvnd, dvsr\n\ndef to_binary(*dec_number):\n  bin_master_list = []\n  def mechanism(dec_number):\n    if(dec_number >= 1):\n      mechanism(dec_number // 2)\n      bin_num.append(dec_number % 2)\n\n  for i in dec_number:\n    bin_num = []\n    mechanism(i)\n    bin_master_list.append(bin_num)\n\n  return bin_master_list\n\ndef static_bit_adjuster(bin_dvnd, bin_dvsr):\n  l1 = len(bin_dvnd)\n  l2 = len(bin_dvsr)\n\n  for i in range(l2, l1 + 1):\n    bin_dvsr.insert(0, 0)\n\ndef ones_complement(binary_num_list):\n  for i in range(0, len(binary_num_list)):\n    if binary_num_list[i] == 0:\n      binary_num_list[i] = 1\n    else:\n      binary_num_list[i] = 0\n\ndef binary_add(list1, list2):\n  carry = 0\n\n  for i in range(len(list1) - 1, -1, -1): #\n    if(carry == 0):\n      if(list1[i] == 0 and list2[i] == 0):\n        list1[i] = 0\n      elif(list1[i] == 0 and list2[i] == 1):\n        list1[i] = 1\n      elif(list1[i] == 1 and list2[i] == 0):\n        list1[i] = 1\n      elif(list1[i] == 1 and list2[i] == 1):\n        list1[i] = 0\n        carry = 1   #\n\n    elif(carry == 1):\n      if(list1[i] == 0 and list2[i] == 0):\n        list1[i] = 1\n        carry = 0\n\n      elif(list1[i] == 0 and list2[i] == 1):\n        list1[i] = 0\n        carry = 1\n\n      elif(list1[i] == 1 and list2[i] == 0):\n        list1[i] = 0\n        carry = 1\n\n      elif(list1[1] == 1 and list2[i] == 1):\n        list1[i] = 1\n        carry = 1 #\n\ndef twos_complement(list1):\n  one = [1]\n  for i in range(0, len(list1)-1):\n    one.insert(0, 0)\n  \n  ones_complement(list1)\n  binary_add(list1, one)\n\n#\ndef ar_left_shift(list1, list2):\n  l1 = len(list1)\n  l2 = len(list2)\n  temp1 = list1.copy()\n  temp2 = list2.copy()\n\n  temp_bit = list2[0]\n  for i in range(l2 - 2, -1, -1):\n    list2[i] = temp2[i + 1]\n  \n  list2[-1] = None\n  list1[-1] = temp_bit\n  for i in range(l1 - 2, -1, -1):\n    list1[i] = temp1[i + 1]\n\ndef list_to_string(list1):\n  string = \"\"\n  for i in list1:\n    if i == None:\n      string += '_'\n    else:\n      string += str(i)\n  \n  return string\n\ndef to_decimal(Q, A):\n  expo = 0\n  dec_quotient = 0\n  dec_remainder = 0\n\n  for i in range(len(Q) - 1, -1, -1):\n    if Q[i] == 1:\n      dec_quotient += 2**expo\n    expo += 1\n\n  expo = 0\n  for i in range(len(A) - 1, -1, -1):\n    if A[i] == 1:\n      dec_remainder += 2**expo\n    expo += 1\n\n  return dec_quotient, dec_remainder\n\ndef non_restoring_division():\n  #\n  dvnd, dvsr = take_input()\n\n  #\n  if dvsr == 0:\n    print(\"{} / {} is undefined! Cannot divide by Zero!\".format(dvnd, dvsr))\n    return \n  if dvnd == 0:\n    print(\"{} / {} = {}\".format(dvnd, dvsr, 0))\n    return\n  \n  #\n  binaries = to_binary(dvnd, dvsr)\n  bin_dvnd = binaries[0] ; bin_dvsr = binaries[1]\n\n  #\n  static_bit_adjuster(bin_dvnd, bin_dvsr)\n\n  #\n  Q = bin_dvnd.copy()\n  M = bin_dvsr.copy()\n  A = [0 for i in range(0, len(M))]\n  count = len(Q)\n  twos_complement(M)\n  minus_M = M.copy()\n  twos_complement(M)\n\n  #\n  table = PrettyTable([\"A\", \"Q\", \"M\", \"Count\", \"Operation\"])\n  final_table = [[list_to_string(A), list_to_string(Q), list_to_string(M), count, \"Start\"]]\n\n  #\n  while count > 0:\n    ar_left_shift(A, Q)\n    final_table.append([list_to_string(A), list_to_string(Q), list_to_string(M), count, \"Arithmetic Left Shift\"])\n\n    if A[0] == 1:\n      binary_add(A, M)\n      final_table.append([list_to_string(A), list_to_string(Q), list_to_string(M), count, \"A = A + M\"])\n    elif A[0] == 0:\n      binary_add(A, minus_M)\n      final_table.append([list_to_string(A), list_to_string(Q), list_to_string(M), count, \"A = A - M\"])\n    \n    #\n    if A[0] == 1:\n      Q[-1] = 0\n    elif A[0] == 0:\n      Q[-1] = 1\n    final_table.append([list_to_string(A), list_to_string(Q), list_to_string(M), count, \"Q_0 = A[MSB]'\"])\n    count -= 1\n  \n  if A[0] == 1:\n    binary_add(A, M)\n    final_table.append([list_to_string(A), list_to_string(Q), list_to_string(M), count, \"A = A + M\"])\n\n  final_table.append(['', '', '', '', \"Finish\"])\n  table.add_rows(final_table)\n  print(table)\n\n  #\n  res = to_decimal(Q, A)\n  print(\"For {} / {}:\\nQuotient = {} ; Remainder = {}\".format(dvnd, dvsr, res[0], res[1]))\n\nnon_restoring_division()",
      "comments": {
        "40": "#reverse traversal",
        "50": "#! Quite important",
        "67": "#! Quite important",
        "77": "#here in RD, lists (A and Q) will not have equal lengths, therfore 2 separate for loops",
        "122": "#*taking user input",
        "125": "#*preconditions",
        "133": "#*preparing binary number list from decimal input",
        "137": "#*Bit adjustments",
        "140": "#*main algorithm preparations",
        "149": "#*table preparation",
        "153": "#*steps of the algorithm",
        "165": "#* Q[LSB] = A[MSB]'",
        "181": "#getting final answer in decimal"
      },
      "OP_ss_dir": "OP_ss/Non_Restoring_Division.py"
    },
    "Preemptive_Task_Scheduling.py": {
      "lang": "py",
      "code_string_literal": "import numpy as np\nimport pandas as pd\nfrom os import system\nimport copy\n\n\ndef take_input():\n  data = []\n  no_of_process = int(input(\"Enter the number of processes: \"))\n\n  for i in range(1, no_of_process + 1):\n    arr_time = int(\n      input(\"Enter the Arrival Time for Process {}: \".format(i)))\n    burst_time = int(\n      input(\"Enter the Burst Time for Process {}: \".format(i)))\n    temp_dict = {'Process No.': i, 'Arrival Time': arr_time,\n                  'Initial Burst Time': burst_time, 'Remaining Time': burst_time}\n    data.append(temp_dict)\n\n  schd_type = int(\n    input(\"Enter the Preemptive scheduler: \\n1. SRTF\\n2. Round-Robin: \"))\n  if (schd_type == 2):\n    time_quantum = int(input(\"Enter the Time Quantum: \"))\n    return data, schd_type, time_quantum\n\n  return data, schd_type, 1\n\n\ndef sort_df(data_frame, by_parameter):\n  sorted_df = data_frame.sort_values(by=by_parameter)\n  sorted_df.reset_index(inplace=True, drop=True)\n\n  return sorted_df\n\n\ndef df_slicer(data_frame, sort_factor, cond_rhs, condition):\n  if condition == \"LESS_THAN_EQUAL\":\n    slice_df = data_frame.loc[data_frame[sort_factor] <= cond_rhs]\n  elif condition == \"GREATER_THAN\":\n    slice_df = data_frame.loc[data_frame[sort_factor] > cond_rhs]\n\n  return slice_df\n\n\ndef redone_gantt_chart(sorted_schd_list, passed_time=0):\n  gantt_list = []\n  passed_time = 0\n  end_times = dict()\n\n  def redone_match_ATPT(curr_passed_time, next_arr_time):\n    if curr_passed_time < next_arr_time:\n      if curr_passed_time == 0:\n        gantt_list.extend([curr_passed_time,\n                            \"\\033[38;5;225midle\", next_arr_time])\n      else:\n        gantt_list.extend(['\\033[38;5;225midle', next_arr_time])\n      return next_arr_time\n\n    elif curr_passed_time == 0:\n      gantt_list.append(curr_passed_time)\n    return curr_passed_time\n\n  for i in sorted_schd_list:\n    passed_time = redone_match_ATPT(passed_time, i[1])\n    passed_time += i[2]\n    gantt_list.extend(['\\033[38;5;225m' + 'P' + str(i[0]), passed_time])\n    end_times.update({i[0]: passed_time})\n  #\n\n  def print_gantt(gantt_list):\n    for i in gantt_list:\n        if i != gantt_list[-1]:\n          print(i, \"\\033[1;90m-> \\033[0m\", end=\"\")\n        else:\n          print(i, end=\"\")\n  print(\"\\033[4m\\033[38;5;225mGantt Chart\\033[0m\")\n  print_gantt(gantt_list)\n\n  return end_times\n\ndef turnaround_time(sorted_df):\n  indv_TAT = []\n\n  for i in range(0, len(sorted_df)):\n    pFT = sorted_df[\"Finish Time\"][i]\n    aT = sorted_df[\"Arrival Time\"][i]\n    indv_TAT.append(pFT - aT)\n\n  avg_TAT = np.average(indv_TAT)\n  sorted_df[\"Turnaround Time\"] = indv_TAT\n  return avg_TAT\n\ndef waiting_time(sorted_df):\n  indv_WT = []  #\n\n  #\n  #\n  for i in range(0, len(sorted_df)):\n    TAT = sorted_df[\"Turnaround Time\"][i]\n    BT = sorted_df[\"Initial Burst Time\"][i]\n    indv_WT.append(TAT - BT)\n\n  avg_WT = np.average(indv_WT)\n  sorted_df[\"Waiting Time\"] = indv_WT\n  return avg_WT\n\n\ndef SRTF(raw_df):\n  AT_sorted_full_df = sort_df(raw_df, \"Arrival Time\")\n  backup = AT_sorted_full_df.copy()\n\n  curr_passed_time = 0\n  per_process_passed_time = 0\n  fully_scheduled = 0\n  schdlist = []\n  noofprocess = raw_df.shape[0]\n  previously_running_proc_no = -1\n\n  while (fully_scheduled != noofprocess):\n    AT_sliced_df = df_slicer(\n      AT_sorted_full_df, \"Arrival Time\", curr_passed_time, \"LESS_THAN_EQUAL\")\n\n    if len(AT_sliced_df) == 0:\n      curr_passed_time += 1\n      continue\n\n    RT_sliced_df = sort_df(AT_sliced_df, \"Remaining Time\")\n    running_proc_no = RT_sliced_df[\"Process No.\"].iloc[0]\n\n    if (running_proc_no != previously_running_proc_no and previously_running_proc_no != -1 and\n      (len(AT_sorted_full_df.loc[AT_sorted_full_df[\"Process No.\"] == previously_running_proc_no]) != 0)):\n      to_schd = AT_sorted_full_df.loc[AT_sorted_full_df[\"Process No.\"] == previously_running_proc_no, [\n          \"Process No.\", \"Arrival Time\", \"Initial Burst Time\"]].values.tolist()[0]\n      to_schd[2] = per_process_passed_time\n      schdlist.append(to_schd)\n      per_process_passed_time = 0\n\n    previously_running_proc_no = running_proc_no\n\n    AT_sorted_full_df.loc[AT_sorted_full_df[\"Process No.\"]\n                            == running_proc_no, \"Remaining Time\"] -= 1\n    curr_passed_time += 1\n    per_process_passed_time += 1\n\n    if (int(AT_sorted_full_df.loc[AT_sorted_full_df[\"Process No.\"] == running_proc_no, \"Remaining Time\"]) == 0):\n      to_schd = AT_sorted_full_df.loc[AT_sorted_full_df[\"Process No.\"] == running_proc_no, [\n        \"Process No.\", \"Arrival Time\", \"Initial Burst Time\"]].values.tolist()[0]\n      to_schd[2] = per_process_passed_time\n      schdlist.append(to_schd)\n      fully_scheduled += 1\n      per_process_passed_time = 0\n      AT_sorted_full_df.drop(\n        AT_sorted_full_df.loc[AT_sorted_full_df[\"Process No.\"] == running_proc_no].index, inplace=True)\n\n  end_times = redone_gantt_chart(schdlist)\n  new_df = backup\n  new_df[\"Remaining Time\"], new_df[\"Finish Time\"] = [0 for i in range(len(new_df))], [0 for i in range(len(new_df))]\n\n  for i in end_times.keys():\n    for j in range(0, len(new_df)):\n      if (int(new_df.loc[j, \"Process No.\"]) == i):\n        new_df.loc[j, \"Finish Time\"] = end_times[i]\n\n  avg_turnaround_time = turnaround_time(new_df)\n  avg_waiting_time = waiting_time(new_df)\n  print(\"\\n\\n\", new_df)\n  print(\"\\nAverage Waiting Time: \\033[1m\\033[4m\\033[38;5;50m{}\\033[0m\\nAverage Turnaround Time: \\033[1m\\033[4m\\033[38;5;50m{}\\033[0m\".format(\n    avg_waiting_time, avg_turnaround_time))\n\n\ndef round_robin(raw_df, quantum=3):\n  AT_sorted_full_df = sort_df(raw_df, \"Arrival Time\")\n  backup = AT_sorted_full_df.copy()\n\n  curr_passed_time = AT_sorted_full_df.loc[0, \"Arrival Time\"]\n  per_process_passed_time = 0\n  fully_scheduled = 0\n  schdlist = []\n  noofprocess = raw_df.shape[0]\n  is_preempted = {key: 0 for key in [i for i in range(0, noofprocess)]}\n  i_flag = 0\n  backup_i = -999\n  i = 0\n\n  while (fully_scheduled != noofprocess):\n    if i == noofprocess:\n      i = 0\n\n    if (i != 0 and i_flag == 1):\n      i -= 1\n      i_flag = 0\n\n    if (AT_sorted_full_df[\"Arrival Time\"].iloc[i] > curr_passed_time):\n      #\n      backup_i = copy.deepcopy(i)\n      for k in range(0, i):\n        if (AT_sorted_full_df[\"Remaining Time\"].iloc[k] > 0 and is_preempted[k] >= 1):\n          i = k\n          break\n\n      if (backup_i == i):\n        curr_passed_time += 1\n        backup_i = -999\n        i += 1\n        i_flag = 1\n        continue\n\n    for j in range(0, quantum):\n      if (is_preempted[i] != -1):\n        AT_sorted_full_df.iloc[i, 3] -= 1\n        curr_passed_time += 1\n        per_process_passed_time += 1\n\n        if (int(AT_sorted_full_df.iloc[i, 3]) == 0):\n          to_schd = AT_sorted_full_df.iloc[i, [\n              0, 1, 2]].values.tolist()\n          to_schd[2] = per_process_passed_time\n          schdlist.append(to_schd)\n          fully_scheduled += 1\n          per_process_passed_time = 0\n          is_preempted[i] = -1\n          break\n\n        elif (per_process_passed_time == quantum):\n          to_schd = AT_sorted_full_df.iloc[i, [\n              0, 1, 2]].values.tolist()\n          to_schd[2] = per_process_passed_time\n          schdlist.append(to_schd)\n          is_preempted[i] += 1\n          per_process_passed_time = 0\n    i += 1\n\n  end_times = redone_gantt_chart(schdlist)\n  new_df = backup\n  new_df[\"Remaining Time\"], new_df[\"Finish Time\"] = [\n      0 for i in range(len(new_df))], [0 for i in range(len(new_df))]\n\n  for i in end_times.keys():\n    for j in range(0, len(new_df)):\n      if (int(new_df.loc[j, \"Process No.\"]) == i):\n        new_df.loc[j, \"Finish Time\"] = end_times[i]\n\n  avg_turnaround_time = turnaround_time(new_df)\n  avg_waiting_time = waiting_time(new_df)\n  print(\"\\n\\n\", new_df)\n  print(\"\\nAverage Waiting Time: \\033[1m\\033[4m\\033[38;5;50m{}\\033[0m\\nAverage Turnaround Time: \\033[1m\\033[4m\\033[38;5;50m{}\\033[0m\".format(\n      avg_waiting_time, avg_turnaround_time))\n\n\ndef caller():\n  system(\"cls\")\n  data, schd_type, time_quantum = take_input()\n  data_frame = pd.DataFrame(data)\n  print(\"\\nRaw DataFrame:\\n\", data_frame, \"\\n\")\n  if schd_type == 1:\n    SRTF(data_frame)\n  elif schd_type == 2:\n    round_robin(data_frame, time_quantum)\n  else:\n    print(\"Invalid Choice!\")\n\ncaller()",
      "comments": {
        "68": "# print(gantt_list)",
        "94": "# in FCFS, the waiting time of the first process will be always 0",
        "96": "#! using formula WT = TAT - BT",
        "97": "# (alternatively, formula can be WT = FTprev - ATcurr)",
        "194": "# check the queue first"
      },
      "OP_ss_dir": "OP_ss/Preemptive_Task_Scheduling.py"
    },
    "Restoring_Division.py": {
      "lang": "py",
      "code_string_literal": "from prettytable import PrettyTable\n\ndef take_input():\n  dvnd = int(input(\"Enter the Dividend: \"))\n  dvsr = int(input(\"Enter the Divisor: \"))\n\n  return dvnd, dvsr\n\ndef to_binary(*dec_number):\n  bin_master_list = []\n  def mechanism(dec_number):\n    if(dec_number >= 1):\n      mechanism(dec_number // 2)\n      bin_num.append(dec_number % 2)\n\n  for i in dec_number:\n    bin_num = []\n    mechanism(i)\n    bin_master_list.append(bin_num)\n\n  return bin_master_list\n\ndef static_bit_adjuster(bin_dvnd, bin_dvsr):\n  l1 = len(bin_dvnd)\n  l2 = len(bin_dvsr)\n\n  for i in range(l2, l1 + 1):\n    bin_dvsr.insert(0, 0)\n\ndef ones_complement(binary_num_list):\n  for i in range(0, len(binary_num_list)):\n    if binary_num_list[i] == 0:\n      binary_num_list[i] = 1\n    else:\n      binary_num_list[i] = 0\n\ndef binary_add(list1, list2):\n  carry = 0\n\n  for i in range(len(list1) - 1, -1, -1): #\n    if(carry == 0):\n      if(list1[i] == 0 and list2[i] == 0):\n        list1[i] = 0\n      elif(list1[i] == 0 and list2[i] == 1):\n        list1[i] = 1\n      elif(list1[i] == 1 and list2[i] == 0):\n        list1[i] = 1\n      elif(list1[i] == 1 and list2[i] == 1):\n        list1[i] = 0\n        carry = 1   #\n\n    elif(carry == 1):\n      if(list1[i] == 0 and list2[i] == 0):\n        list1[i] = 1\n        carry = 0\n\n      elif(list1[i] == 0 and list2[i] == 1):\n        list1[i] = 0\n        carry = 1\n\n      elif(list1[i] == 1 and list2[i] == 0):\n        list1[i] = 0\n        carry = 1\n\n      elif(list1[1] == 1 and list2[i] == 1):\n        list1[i] = 1\n        carry = 1 #\n\ndef twos_complement(list1):\n  one = [1]\n  for i in range(0, len(list1)-1):\n    one.insert(0, 0)\n  \n  ones_complement(list1)\n  binary_add(list1, one)\n\n#\ndef ar_left_shift(list1, list2):\n  l1 = len(list1)\n  l2 = len(list2)\n  temp1 = list1.copy()\n  temp2 = list2.copy()\n\n  temp_bit = list2[0]\n  for i in range(l2 - 2, -1, -1):\n    list2[i] = temp2[i + 1]\n  \n  list2[-1] = None\n  list1[-1] = temp_bit\n  for i in range(l1 - 2, -1, -1):\n    list1[i] = temp1[i + 1]\n\ndef list_to_string(list1):\n  string = \"\"\n  for i in list1:\n    if i == None:\n      string += '_'\n    else:\n      string += str(i)\n  \n  return string\n\ndef to_decimal(Q, A):\n  expo = 0\n  dec_quotient = 0\n  dec_remainder = 0\n\n  for i in range(len(Q) - 1, -1, -1):\n    if Q[i] == 1:\n      dec_quotient += 2**expo\n    expo += 1\n\n  expo = 0\n  for i in range(len(A) - 1, -1, -1):\n    if A[i] == 1:\n      dec_remainder += 2**expo\n    expo += 1\n\n  return dec_quotient, dec_remainder\n\ndef restoring_division():\n  #\n  dvnd, dvsr = take_input()\n\n  #\n  if dvsr == 0:\n    print(\"{} / {} is undefined! Cannot divide by Zero!\".format(dvnd, dvsr))\n    return \n  if dvnd == 0:\n    print(\"{} / {} = {}\".format(dvnd, dvsr, 0))\n    return \n\n  #\n  binaries = to_binary(dvnd, dvsr)\n  bin_dvnd = binaries[0] ; bin_dvsr = binaries[1]\n\n  #\n  static_bit_adjuster(bin_dvnd, bin_dvsr)\n\n  #\n  Q = bin_dvnd.copy()\n  M = bin_dvsr.copy()\n  A = [0 for i in range(0, len(M))]\n  count = len(Q)\n  twos_complement(M)\n  minus_M = M.copy()\n  twos_complement(M)\n\n  #\n  table = PrettyTable([\"A\", \"Q\", \"M\", \"Count\", \"Operation\"])\n  final_table = [[list_to_string(A), list_to_string(Q), list_to_string(M), count, \"Start\"]]\n\n  #\n  while count > 0:\n    ar_left_shift(A, Q)\n    final_table.append([list_to_string(A), list_to_string(Q), list_to_string(M), count, \"Arithmetic Left Shift\"])\n    binary_add(A, minus_M)\n    final_table.append([list_to_string(A), list_to_string(Q), list_to_string(M), count, \"A = A - M\"])\n\n    if A[0] == 1:\n      Q[-1] = 0\n      final_table.append([list_to_string(A), list_to_string(Q), list_to_string(M), count, \"MSB[A] = 1, Q_0 = 0\"])\n      binary_add(A, M) #\n      final_table.append([list_to_string(A), list_to_string(Q), list_to_string(M), count, \"(Restore A), A = A + M\"])\n    elif A[0] == 0:\n      Q[-1] = 1\n      final_table.append([list_to_string(A), list_to_string(Q), list_to_string(M), count, \"MSB[A] = 0, Q_0 = 1\"])\n\n    count -= 1\n\n  final_table.append(['', '', '', '', \"Finish\"])\n  table.add_rows(final_table)\n  print(table)\n\n  #\n  res = to_decimal(Q, A)\n  print(\"For {} / {}:\\nQuotient = {} ; Remainder = {}\".format(dvnd, dvsr, res[0], res[1]))\n\nrestoring_division()",
      "comments": {
        "40": "#reverse traversal",
        "50": "#! Quite important",
        "67": "#! Quite important",
        "77": "#here in RD, lists (A and Q) will not have equal lengths, therfore 2 separate for loops",
        "122": "#*taking user input",
        "125": "#*preconditions",
        "133": "#*preparing binary number list from decimal input",
        "137": "#*Bit adjustments",
        "140": "#*main algorithm preparations",
        "149": "#*table preparation",
        "153": "#*steps of the algorithm",
        "163": "#! Restoration of A",
        "175": "#getting final answer in decimal"
      },
      "OP_ss_dir": "OP_ss/Restoring_Division.py"
    }
  },
  "Sem_V-IS": {
    "Caesar_Cipher_95.py": {
      "lang": "py",
      "code_string_literal": "#\n\ndef caesar_encrypt(plain_text: str, key: int):\n  cipher_text = \"\"\n  for i in plain_text:\n    cipher_text += chr(((ord(i) + key - 32) % 95) + 32)\n  return cipher_text\n\ndef caesar_decrypt(cipher_text: str, key: int):\n  plain_text = \"\"\n  for i in cipher_text:\n    plain_text += chr(((ord(i) - key - 32) % 95) + 32)\n  return plain_text\n\ndef caesar_cipher():\n  plain_text = input(\"Enter the plain text: \")\n  key = int(input(\"Enter the key (shift, preferably 0 < key < 95): \"))\n  cipher_text = caesar_encrypt(plain_text, key)\n  print(\"Encrypted Text: \", cipher_text)\n  plain_text = caesar_decrypt(cipher_text, key)\n  print(\"Decrypted Text: \", plain_text)\n\ncaesar_cipher()",
      "comments": {
        "1": "#~ A simple python program to implement caesar cipher encryption and decryption using 95 valid (keyboard type-able) characters"
      },
      "OP_ss_dir": "OP_ss/Caesar_Cipher_95.py"
    },
    "Columnar_Transposition.py": {
      "lang": "py",
      "code_string_literal": "\n#\n\n#\ndef ctp_encryption(plain_text: str, key: str):\n  keylen, ptlen = len(key), len(plain_text)\n  cipher_text = \"\"\n  enc_mx = [list(plain_text[i: i + keylen]) for i in range(0, ptlen - keylen + 1, keylen)]      #\n\n  keylist = list(key)\n  sorted_keylist = sorted(list(key))\n  included_indx = []\n\n  #\n  for i in range(len(sorted_keylist)):\n    for j in range(len(keylist)):\n      if sorted_keylist[i] == keylist[j] and j not in included_indx:           #\n        for row in range(len(enc_mx)):\n          cipher_text += enc_mx[row][j]\n        included_indx.append(j)\n        break\n\n  return cipher_text\n\n#\ndef ctp_decryption(cipher_text: str, key: str):\n  plain_text = \"\"\n  keylen, ctlen = len(key), len(cipher_text)\n  dec_mx = [[0 for i in range(keylen)] for j in range(int(ctlen / keylen))]\n  ct_curr_indx = 0\n  \n  keylist, sorted_keylist = list(key), sorted(list(key))      #\n  included_indx = []\n\n  for i in range(len(sorted_keylist)):\n    for j in range(len(keylist)):\n      if sorted_keylist[i] == keylist[j] and j not in included_indx:           \n        for row in range(len(dec_mx)):\n          dec_mx[row][j] = cipher_text[ct_curr_indx]\n          ct_curr_indx += 1\n        included_indx.append(j)\n        break\n\n  for _ in range(len(dec_mx)):\n    plain_text += \"\".join(dec_mx.pop(0))\n\n  return plain_text\n\ndef columnar_tp():\n  print(\"Columnar Transposition\")\n  plain_text = input(\"Enter the plain text (preferably ALL CAPS, no SPACE): \").upper().replace(\" \", \"\")\n  key = input(\"Enter the key (preferably shorter than the Plaintext or it will be sliced): \")[:len(plain_text)].upper().replace(\" \", \"\")\n  keylen = len(key)\n  while True:\n    if len(plain_text) % keylen != 0:\n      plain_text += '_'\n    else:\n      break\n  cipher_text = ctp_encryption(plain_text, key)\n  print(\"Cipher Text: \", cipher_text)\n  plain_text = ctp_decryption(cipher_text, key)\n  print(\"Plain Text: \", plain_text)\n\ncolumnar_tp()",
      "comments": {
        "2": "#~ Python program to implement columnar transposition cipher",
        "4": "# Encryption -> Encryption_mx => PLaintext filled row-wise; According to the alphabetic order of the key's chars. pick columns in enc_mx and append those chars. in cipher_text",
        "8": "#~ +1 because endpoint is excluded but I want it included (NTS: Maybe do it the DES way)(Another NTS: Don't keep it as list of single strings, keep it as list of chars.)",
        "14": "# range used to not have to use 'index' function which inevitably returns index of first find   ",
        "17": "# if characters are equal and the index of the char. in the o.g keylist is not already used, use it as the column index for the enc_mx",
        "25": "# Decryption -> fill the columns with slices of cipher_text based on the same ascending-arrangement of the key",
        "32": "# I've not imported this from the encryption block to keep the essence of messaging between 2 users, receiver will have to process the key on their own"
      },
      "OP_ss_dir": "OP_ss/Columnar_Transposition.py"
    },
    "DH_Key_Exchange.py": {
      "lang": "py",
      "code_string_literal": "def DHKE():\n  g, p = 5, 23\n  a, b = 4, 3\n  Xa = (g ** a) % p\n  Xb = (g ** b) % p\n  SSA = (Xb ** a) % p\n  SSB = (Xa ** b) % p\n  if SSA == SSB:\n    print(\"Connection Established\")\n\nDHKE()",
      "comments": {},
      "OP_ss_dir": "OP_ss/DH_Key_Exchange.py"
    },
    "Double_Columnar_Transposition.py": {
      "lang": "py",
      "code_string_literal": "#\n#\n\ndef text_padding(text, keylen):\n  while len(text) % keylen != 0:\n    text += '_'\n  return text\n\ndef key_orderer(key):\n  key_list = list(key)\n  sorted_key_list = list(sorted(key))\n  col_order = [] \n  for i in range(len(sorted_key_list)):\n    for j in range(len(key_list)):\n      if sorted_key_list[i] == key_list[j] and j not in col_order:\n        col_order.append(j)\n        break\n  return col_order\n\ndef columnar_tp_encryption(plain_text, key, other_key):\n  cipher_text = \"\"\n  keylen = len(key)\n  col_order = key_orderer(key)\n  if len(plain_text) % len(key) != 0:           #\n    plain_text = text_padding(plain_text, keylen)\n  ptlen = len(plain_text)                            #\n  enc_mx = [list(plain_text[i - keylen: i]) for i in range(keylen, ptlen + 1, keylen)]\n  \n  for col in col_order:\n    cipher_text += \"\".join([enc_mx[row][col] for row in range(len(enc_mx))])\n  return cipher_text, f\"{ptlen}\"\n\ndef columnar_tp_decryption(cipher_text, key):\n  plain_text = \"\"\n  keylen = len(key)\n  col_order = key_orderer(key)\n  ctlen = len(cipher_text)                    \n  dec_mx = [[0 for _ in range(keylen)] for _ in range(int(ctlen / keylen))]\n  ct_curr_indx = 0\n  \n  for col in col_order:\n    for row in range(len(dec_mx)):\n      dec_mx[row][col] = cipher_text[ct_curr_indx]\n      ct_curr_indx += 1\n\n  for _ in range(len(dec_mx)):\n    plain_text += \"\".join(dec_mx.pop(0))\n  \n  return plain_text\n\ndef double_columnar_encryption(plain_text: str, key1: str, key2: str):\n  intermediate_ct, intermediate_ptlen = columnar_tp_encryption(plain_text, key1, key2)\n  final_ct = columnar_tp_encryption(intermediate_ct, key2, key1)[0] + \"\u2265\" + intermediate_ptlen\n  return final_ct \n\ndef double_columnar_decryption(cipher_text, key1: str, key2: str):\n  intermediate_ptlen = int(cipher_text[cipher_text.index(\"\u2265\") + 1:])\n  cipher_text = cipher_text[:cipher_text.index(\"\u2265\")]\n  intermediate_pt = columnar_tp_decryption(cipher_text, key2)\n  intermediate_pt = intermediate_pt[:intermediate_ptlen]\n  final_pt = columnar_tp_decryption(intermediate_pt, key1)\n  return final_pt\n  \ndef double_columnar():\n  plain_text = input(\"Enter the plain text (preferably all caps, no space): \").upper().replace(\" \", \"\")\n  key1 = input(\"Enter the first key (preferably len(key) < len(plain_text)): \")[:len(plain_text)].upper().replace(\" \", \"\")\n  key2 = input(\"Enter the second key (preferably len(key) < len(plain_text)): \")[:len(plain_text)].upper().replace(\" \", \"\")\n  print(\"\\033[38;5;149mEntered Text:\", plain_text, \"\\033[0m\")\n\n  cipher_text = double_columnar_encryption(plain_text, key1, key2)\n  print(\"\\033[38;5;197mCipher Text:\", cipher_text, \"\\033[0m\")\n  plain_text = double_columnar_decryption(cipher_text, key1, key2)\n  print(\"\\n\\033[38;5;205mDeciphered Text:\", plain_text, \"\\033[0m\")\n\ndouble_columnar()",
      "comments": {
        "1": "#~ Implementing Double Columnar Transposition symmetric cryptography (See columnar_tp.py for explanation)",
        "2": "#!NTS at the end \u2193",
        "24": "# if padding required then only call the padding function ",
        "26": "# length of plaintext should always be taken after padding"
      },
      "OP_ss_dir": "OP_ss/Double_Columnar_Transposition.py"
    },
    "Electronic_Code_Book.py": {
      "lang": "py",
      "code_string_literal": "#\n\ndef text_padder(text):\n  while len(text) % 16 != 0:\n    text += '_'\n  return text\n\ndef dec_to_binary(dec_num):\n  def mechanism(num):\n    if num >= 1:\n      mechanism(num // 2)\n      bin_list.append(num % 2)\n  bin_list = []\n  mechanism(dec_num)\n  return bin_list\n\n#\ndef ascii_list_binarizer(ascii_list):\n  binary_list = []\n  for num in ascii_list:\n    pad_to_8 = dec_to_binary(num)           #\n    while(len(pad_to_8) != 8):\n      pad_to_8.insert(0, 0)\n    binary_list.extend(pad_to_8)\n  return binary_list\n\n#\ndef list_XOR(list_a, list_b):\n  XORed = []\n  for x, y in zip(list_a, list_b):\n    XORed.append(x ^ y)     #\n  return XORed\n\ndef binary_to_ascii(eight_bits):\n  dec_number = 0\n  for i in range(len(eight_bits) - 1, -1, -1):\n    if eight_bits[i] == 1:\n      dec_number += 2 ** (len(eight_bits) - 1 - i)\n  return dec_number\n\ndef bin_list_asciirizer(bin_list):\n  ascii_list = []\n  for eight_indx in range(8, len(bin_list) + 1, 8):\n    ascii_list.append(binary_to_ascii(bin_list[eight_indx - 8: eight_indx]))\n  return ascii_list\n\ndef electronic_code_book_encryption(plain_text, key, shift):\n  #\n  pt_ascii_blocks = [list(map(lambda x: ord(x), list(plain_text[i - 16: i]))) for i in range(16, len(plain_text) + 1, 16)]       \n  #\n  pt_128_blocks = []\n  for block in pt_ascii_blocks:\n    pt_128_blocks.append(ascii_list_binarizer(block))\n\n  #\n  key_128 = ascii_list_binarizer(list(map(lambda x: ord(x), list(key))))\n\n  #\n  for i in range(shift):\n    for block in pt_128_blocks:\n      block.append(block.pop(0))  \n    \n  #\n  for b_indx in range(len(pt_128_blocks)):\n    pt_128_blocks.append(list_XOR(pt_128_blocks[b_indx], key_128))\n  pt_128_blocks = pt_128_blocks[len(pt_128_blocks) // 2:]               #\n\n  #\n  cipher_text = \"\"\n  for block in pt_128_blocks:\n    cipher_text += \"\".join(list(map(lambda x: chr(x), bin_list_asciirizer(block))))\n  return cipher_text\n\ndef electronic_code_book_decryption(cipher_text, key, shift):\n  #\n  key_128 = ascii_list_binarizer(list(map(lambda x: ord(x), list(key))))\n  ct_ascii_blocks = [list(map(lambda x: ord(x), list(cipher_text[i - 16: i]))) for i in range(16, len(cipher_text) + 1, 16)]\n  ct_128_blocks = []\n  for block in ct_ascii_blocks:\n    ct_128_blocks.append(ascii_list_binarizer(block))\n\n  #\n  for b_indx in range(len(ct_128_blocks)):\n    ct_128_blocks.append(list_XOR(ct_128_blocks[b_indx], key_128))\n  ct_128_blocks = ct_128_blocks[len(ct_128_blocks) // 2:]         \n  \n  #\n  for i in range(shift):\n    for block in ct_128_blocks:\n      block.insert(0, block.pop(-1))\n    \n  plain_text = \"\"\n  for block in ct_128_blocks:\n    plain_text += \"\".join(list(map(lambda x: chr(x), bin_list_asciirizer(block))))\n  return plain_text\n\ndef electronic_code_book():\n  plain_text = \"Dolore commodo nulla fugiat proident.Id sit dolore proident aliquip laboris aliqua fugiat ullamco cupidatat duis eiusmod occaecat nostrud cupidatat.\"\n  print(\"\\033[38;5;85mOriginal Plain Text:\", plain_text, \"\\033[0m\")\n  plain_text = text_padder(plain_text)\n  key = input(\"Enter the 16 character key string: \")[:16]\n  shift = int(input(\"Enter the shift amount 't': \"))\n  cipher_text = electronic_code_book_encryption(plain_text, key, shift)\n  print(\"\\033[38;5;197mCipher Text:\", cipher_text, \"\\033[0m\")\n  plain_text = electronic_code_book_decryption(cipher_text, key, shift)\n  print(\"\\033[38;5;209mDeciphered Text:\", plain_text, \"\\033[0m\")\n  \nelectronic_code_book()",
      "comments": {
        "1": "#~ Implementing Electronic Code Book Block Cipher technique (t-shifts)",
        "17": "# the -izer suffix just sounds funny to me so used it lol",
        "21": "# dec to bin only returns significant bits, have to pad for uniform 8 bit representation, 8 bits can represent till 255(included) and that's okay for 1 left shift of any english keyboard char ~(126) x 2 = 252 < 255",
        "27": "#* both list_a and list_b are lists of 128 bits",
        "31": "# shorthand for XOR in python is ^, don't confuse it with power!",
        "48": "# A list of lists containing 16 ascii values representing 16 chars. splits (blocks) of plain text",
        "50": "# list of lists containing 128 binary bits for 16 ascii values (1 ascii value -> 8 bits of binary digits, 16 x 8 = 128 bits)",
        "55": "# converting the 16 char. key string to 128 bits similarly",
        "58": "# circular left shift each block of pt_128 individually (that's what block cipher wants to achieve, separated encryption)",
        "63": "# XORing each 128 bits block with key's 128 bits",
        "66": "# the latter half of the main list is containing the actual XORed result",
        "68": "# forming the cipher_text in string format (which will be equal to the length of plain_text) from the blocks of bits",
        "75": "# getting the required setup of blocks of 128 bits (same as plain_text)",
        "82": "# Since XOR was the last thing done when encrypting, it will be the first thing done when decrypting (also XOR because XORing an XOR brings us back to the starting bits)",
        "87": "# now the XOR'ed bits are to be circular right shifted, i.e the reverse direction"
      },
      "OP_ss_dir": "OP_ss/Electronic_Code_Book.py"
    },
    "Hill_Cipher_3x3.py": {
      "lang": "py",
      "code_string_literal": "#\nimport numpy as np\nimport math\nfrom typing import List\n\ndef dynamic_list_slicer(list_, slice_size):\n  return [list_[i - slice_size: i] for i in range(slice_size, len(list_) + 1, slice_size)]\n\ndef return_reqd_matrices(text, key, return_pt_matrices = True):\n  char_decimal_eqv = {chr(i): i - 65 for i in range(65, 91)}\n  key_mx = dynamic_list_slicer(list(map(lambda x: char_decimal_eqv[x], list(key))), 3)\n  if return_pt_matrices:\n    text_blocks = dynamic_list_slicer(list(map(lambda x: char_decimal_eqv[x], list(text))), 9)    #\n    text_cde_matrices = [[block[i - 3: i] for i in range(3, len(block) + 1, 3)] for block in text_blocks]\n    return text_cde_matrices, key_mx\n  else:\n    return key_mx\n  \ndef hill_cipher_encryption(plain_text, key):\n  decimal_char_eqv = {i - 65: chr(i) for i in range(65, 91)}\n  cipher_text = \"\"\n  \n  pt_matrices, key_mx = return_reqd_matrices(plain_text, key)\n  print(\"Key matrix: \", key_mx)\n  print(\"Plain Text Matrices: \", pt_matrices)\n  \n  encrypted_matrices = []\n  for pt_mx in pt_matrices:\n    enc_mx = (np.dot(key_mx, pt_mx) % 26).tolist()\n    encrypted_matrices.append(enc_mx)\n  \n  print(\"Encrypted Matrices: \", encrypted_matrices)\n  for ct_mx in encrypted_matrices:\n    cipher_text += \"\".join([decimal_char_eqv[col] for row in ct_mx for col in row])\n  return cipher_text\n\n#\ndef extended_euclidean_algorithm(b, a = 26):\n  exe_table = {'x': [1, 0], 'y': [0, 1], 'r': [a, b], 'q': [-1]} \n  #\n  while exe_table['r'][-1] != 1:                                         \n    exe_table['q'].append(math.floor(exe_table['r'][-2] / exe_table['r'][-1]))  \n    exe_table['x'].append(exe_table['x'][-2] - exe_table['x'][-1] * exe_table['q'][-1])    \n    exe_table['y'].append(exe_table['y'][-2] - exe_table['y'][-1] * exe_table['q'][-1])\n    exe_table['r'].append(exe_table['r'][-2] % exe_table['r'][-1])\n    #\n  return (exe_table['y'][-1]) % a         #\n\ndef find_key_adj_mx(key_mx):\n  indices = [(i, j) for i in range(3) for j in range(3)]\n  cofactor_key_mx = [[0 for i in range(len(key_mx))] for j in range(len(key_mx))]\n  for i in range(len(cofactor_key_mx)):\n    for j in range(len(cofactor_key_mx)):\n      #\n      minor_mx = dynamic_list_slicer([key_mx[inx[0]][inx[1]] for inx in indices if inx[0] != i and inx[1] != j], 2)     #\n      #\n      cofactor_key_mx[i][j] = ((-1) ** (i + j)) * round(np.linalg.det(minor_mx))\n  adj_key_mx = (np.transpose(np.array(cofactor_key_mx)) % 26).tolist()\n  return adj_key_mx\n\ndef hill_cipher_decryption(cipher_text, key):\n  decimal_char_eqv = {i - 65: chr(i) for i in range(65, 91)}\n  plain_text = \"\"\n  ct_matrices, key_mx = return_reqd_matrices(cipher_text, key)\n  print(\"Key matrix: \", key_mx)\n  print(\"Cipher Text Matrices: \", ct_matrices)\n\n  #\n  #\n  det_key_mx = round(np.linalg.det(np.array(key_mx))) % 26\n  print(\"Determinant of Key Matrix: \", det_key_mx)\n  #\n  inverted_det = extended_euclidean_algorithm(det_key_mx)\n  print(\"Inverted Key Matrix Determinant: \", inverted_det)\n  \n  #\n  adj_key_mx = find_key_adj_mx(key_mx)\n  print(\"Adjoint Key Matrix: \", adj_key_mx)\n  \n  #\n  inv_key_mx = ((np.array(adj_key_mx) * inverted_det) % 26).tolist()\n  print(\"Inverse Key Matrix: \", inv_key_mx)\n\n  decrypted_matrices = []\n  for ct_mx in ct_matrices:\n    decrypted_matrices.append((np.dot(inv_key_mx, ct_mx) % 26).tolist())\n  \n  for dct_mx in decrypted_matrices:\n    plain_text += \"\".join([decimal_char_eqv[col] for row in dct_mx for col in row])\n  \n  return plain_text\n\ndef suggest_valid_keys(key_mx: list):\n  decimal_char_eqv = {i - 65: chr(i) for i in range(65, 91)} \n  for row_i in range(len(key_mx)):\n    for col_i in range(len(key_mx)):\n      og_value = key_mx[row_i][col_i]\n      for i in range(26):\n        key_mx[row_i][col_i] = (key_mx[row_i][col_i] + i) % 26\n        #\n        if math.gcd(round(np.linalg.det(key_mx)) % 26, 26) == 1:\n          #\n          print(\"\".join([decimal_char_eqv[j] for i in key_mx for j in i]))\n      key_mx[row_i][col_i] = og_value\n\n#\ndef validate_key(plain_text, key):\n  key_mx = return_reqd_matrices(plain_text, key, False)\n  det_key_mx = round(np.linalg.det(np.array(key_mx))) % 26\n  #\n  if det_key_mx == 0 or math.gcd(26, det_key_mx) != 1:\n    while det_key_mx == 0 or math.gcd(26, det_key_mx) != 1:\n      suggest_valid_keys(key_mx)\n      key = input(\"Key was invalid, please use one of the suggested keys based on your key(if no suggestions, try another random key): \")[:9].upper().replace(\" \", \"\")\n      key_mx = return_reqd_matrices(plain_text, key, False)\n      det_key_mx = round(np.linalg.det(np.array(key_mx))) % 26\n  \n  return key\n\ndef hill_cipher():\n  plain_text = input(\"Enter the plain text (uppercase English Alphabets only): \").upper().replace(\" \", \"\")\n  while len(plain_text) % 9 != 0:\n    plain_text += 'X'\n  key = input(\"Enter the 9-letter key: \")[:9].upper().replace(\" \", \"\")\n  while len(key) != 9:\n    key += 'X'\n  \n  key = validate_key(plain_text, key)\n  \n  cipher_text = hill_cipher_encryption(plain_text, key)\n  print(\"\\033[38;2;240;10;10mCipher Text: \", cipher_text, \"\\033[0m\")\n  plain_text = hill_cipher_decryption(cipher_text, key)\n  print(\"\\033[38;2;10;240;10mDeciphered Text: \", plain_text, \"\\033[0m\")\n\nhill_cipher()",
      "comments": {
        "1": "#~ A simple Python program to implement Hill Cipher (Encryption and Decryption)",
        "13": "# each block is of len = 9, 3 x 3 matrices will be formed for each block",
        "37": "# !for a multiplicative inverse to exist, the terms a and b must be co-prime... and in range 2-26 here",
        "40": "# print(exe_table)        ",
        "46": "# print(exe_table, end=\"\\n\\n\")",
        "47": "# taking care of additive inverse if applicable",
        "54": "# print(i, j, key_mx[i][j], end = \"  \")",
        "55": "# follows the exact logic in finding minor matrix manually",
        "56": "# print(minor_mx)",
        "68": "#! Finding key_inv_mx (base 26)",
        "69": "#~ Finding Determinant of key matrix, cannot have a singular matrix i.e det = 0 cause those are not invertible",
        "72": "#~ Modulo multiplicative inverse of the det (base 26)",
        "76": "#~ getting the adjoint matrix",
        "80": "#~ getting the inverse key matrix by inv_key_mx = adj_key_mx / det(key_mx)",
        "100": "# print(*key_mx)",
        "102": "# print(round(np.linalg.det(key_mx)) % 26, \"\".join([decimal_char_eqv[j] for i in key_mx for j in i]))",
        "106": "# passing plain_text just so I can call the return_reqd_matrices function",
        "110": "# print(det_key_mx)"
      },
      "OP_ss_dir": "OP_ss/Hill_Cipher_3x3.py"
    },
    "Playfair_Cipher.py": {
      "lang": "py",
      "code_string_literal": "#\nfrom itertools import permutations\n\ndef process_pt(text: str):\n  pairs, idx = [], 2\n  while idx <= len(text) + 1:\n    pair = text[idx - 2: idx]\n    if len(pair) == 1:                          #\n      text += 'X' if text[-1] != 'X' else 'Y'\n      continue      \n    if pair[0] == pair[1] or (pair[0] == \"I\" and pair[1] == \"J\") or (pair[0] == \"J\" and pair[1] == \"I\"):        #\n      text = text[:idx - 1] + \"X\" + text[idx - 1:]\n      continue\n    pairs.append(pair)      \n    idx += 2\n  return pairs\n\ndef unique_chars(text: str):\n  unique = []\n  for c in text:\n    if c not in unique:\n      unique.append(c)\n  return unique\n\ndef make_enc_mx(key: str):\n  enc_mx = []\n  enc_mx.extend(unique_chars(key))\n  for i in range(65, 91):\n    if chr(i) not in enc_mx:\n      enc_mx.append(chr(i))\n\n  #\n  enc_mx.pop(enc_mx.index('J'))\n  return [enc_mx[i - 5: i] for i in range(5, len(enc_mx) + 1, 5)]     #\n\ndef give_rc_inx(mx, char):\n  char = 'I' if char == 'J' else char\n  for row in range(len(mx)):\n    for col in range(len(mx[row])):\n      if mx[row][col] == char:\n        return row, col\n  return -1, -1\n\ndef playfair_encryption(plain_text: str, key: str):\n  cipher_text = \"\"\n  enc_mx = make_enc_mx(key)\n  #\n  pt_ch_pairs = process_pt(plain_text)\n  for pair in pt_ch_pairs:\n    r1, c1 = give_rc_inx(enc_mx, pair[0])\n    r2, c2 = give_rc_inx(enc_mx, pair[1])\n    #\n    if r1 == r2:\n      cipher_text += (enc_mx[r1][(c1 + 1) % 5] + enc_mx[r2][(c2 + 1) % 5])\n    elif c1 == c2:\n      cipher_text += (enc_mx[(r1 + 1) % 5][c1] + enc_mx[(r2 + 1) % 5][c2])\n    else:\n      cipher_text += (enc_mx[r1][c2] + enc_mx[r2][c1])\n  return cipher_text\n\n#\ndef all_pt_perms(plain_text: str):\n  pt_perms = []\n  i_idx_psns = [i for i in range(len(plain_text)) if plain_text[i] == \"I\"]\n  ij_perms = []\n  for itr in range(len(i_idx_psns) + 1):    #\n    ij_perms.extend(list(permutations(i_idx_psns, itr)))\n  \n  for perm in ij_perms:\n    pt_list = list(plain_text)\n    for idx in perm:\n      pt_list[idx] = 'J'\n    pt_perms.append(\"\".join(pt_list))\n  return list(set(pt_perms))\n\ndef playfair_decryption(cipher_text: str, key: str):\n  plain_text = \"\"\n  enc_mx = make_enc_mx(key)\n  ct_ch_pairs = process_pt(cipher_text)\n  \n  for pair in ct_ch_pairs:\n    r1, c1 = give_rc_inx(enc_mx, pair[0])\n    r2, c2 = give_rc_inx(enc_mx, pair[1])\n    if r1 == r2:\n      plain_text += (enc_mx[r1][(c1 - 1) % 5] + enc_mx[r2][(c2 - 1) % 5])\n    elif c1 == c2:\n      plain_text += (enc_mx[(r1 - 1) % 5][c1] + enc_mx[(r2 - 1) % 5][c2])\n    else:\n      plain_text += (enc_mx[r1][c2] + enc_mx[r2][c1])\n  \n  pt_perms = all_pt_perms(plain_text)\n  return pt_perms\n\ndef playfair():\n  plain_text = input(\"Enter the message: \").upper().replace(\" \", \"\")\n  key = input(\"Enter the key (preferably len(key) < len(plain_text): \")[:len(plain_text)].upper().replace(\" \", \"\")\n  cipher_text = playfair_encryption(plain_text, key)\n  print(\"Cipher Text:\\033[38;5;197m\", cipher_text,\"\\033[0m\\n\")\n  all_pt = playfair_decryption(cipher_text, key)\n  for i in range(len(all_pt)):\n    print(f\"\\033[38;2;{255 if i % 2 != 0 else 0};{255 if i % 2 == 0 else 75};{220 if i % 2 == 0 else 130}m{i}: {all_pt[i]}\")\n  print(\"\\033[0m\")\nplayfair()",
      "comments": {
        "1": "#~ Implementing playfair cipher for uppercase English alphabets",
        "8": "# safeguarding from index out of range errors at the last pair",
        "11": "# Have to especially consider consequent IJ occurences ",
        "32": "#! This variation of playfair cipher always treats Js as Is",
        "34": "# converted to 2D",
        "47": "# print(*enc_mx, sep=\"\\n\")",
        "52": "# print(f\"{pair}: {r1, c1}, {r2, c2}\")",
        "61": "#! Showing all possible texts to the receiver if the decrypted text contains 'I' (maybe reduces security levels but I feel it enhances receiver's exp)",
        "66": "# counts from 0 till all Is i.e no change to all Is as well as all Is changed to J"
      },
      "OP_ss_dir": "OP_ss/Playfair_Cipher.py"
    },
    "Simplified_DES.py": {
      "lang": "py",
      "code_string_literal": "#\n\nfrom copy import deepcopy\ndef dec_to_binary(dec_num):\n  def mechanism(num):\n    if num >= 1:\n      mechanism(num // 2)\n      bin_list.append(num % 2)\n  bin_list = []\n  mechanism(dec_num)\n  return bin_list\n\ndef ascii_list_binarizer(ascii_list):\n  binary_list = []\n  for num in ascii_list:\n    bin_num = dec_to_binary(num)\n    while len(bin_num) != 8:        #\n      bin_num.insert(0, 0)\n    binary_list.extend(bin_num)\n  return binary_list\n\ndef dynamic_list_pooler(list_, pool_size):\n  pooled_list = []\n  for i in range(pool_size, len(list_) + 1, pool_size):\n    pooled_list.append(list_[i-pool_size: i])\n  return pooled_list\n\ndef bin_to_decimal(eight_bits):\n  dec_number = 0\n  for i in range(len(eight_bits) - 1, -1, -1):\n    if eight_bits[i] == 1:\n      dec_number += 2 ** (len(eight_bits) - 1 - i)\n  return dec_number\n\ndef bin_list_asciirizer(bin_list, poolrange = 8):\n  ascii_list = []\n  for block_inx in range(poolrange, len(bin_list) + 1, poolrange):\n    ascii_list.append(bin_to_decimal(bin_list[block_inx-poolrange: block_inx]))\n  return ascii_list\n\ndef expansion_permutation(RPT):\n  RPT_8_4 = dynamic_list_pooler(RPT, 4)\n  RPT_8_6 = []\n  for i in range(len(RPT_8_4)):\n    RPT_8_6.append(deepcopy(RPT_8_4[i]))\n    RPT_8_6[-1].insert(0, RPT_8_4[(i - 1) % 8][-1])\n    RPT_8_6[-1].append(RPT_8_4[(i + 1) % 8][0])\n  \n  #\n  RPT_48 = []\n  [(RPT_48.extend(i)) for i in RPT_8_6]\n  return RPT_48\n\ndef s_box_substitution(RPT_48, s_box):\n  RPT_8_6 = dynamic_list_pooler(RPT_48, 6)\n  RPT_8_4 = []\n  for block in RPT_8_6:\n    RPT_8_4.append(dec_to_binary(s_box[bin_to_decimal([block[0], block[-1]])][bin_to_decimal(block[1:5])]))\n    while len(RPT_8_4[-1]) != 4:    #\n      RPT_8_4[-1].insert(0, 0)\n  \n  RPT_32 = []\n  [RPT_32.extend(i) for i in RPT_8_4]\n  return RPT_32\n\ndef function_block(RPT_32, key_48, s_box):\n  #\n  RPT_48 = expansion_permutation(RPT_32)\n  \n  #\n  for i in range(len(RPT_48)):\n    RPT_48[i] = RPT_48[i] ^ key_48[i]\n\n  #\n  RPT_32 = s_box_substitution(RPT_48, s_box)  \n  return RPT_32\n\ndef simplified_DES_encryption(pt_64, keys_48, s_box, noofrounds = 2):\n  cipher_text = \"\"\n  curr_round = 1\n  LPT, RPT = pt_64[:32], pt_64[32:]\n  while curr_round <= noofrounds:\n    #\n    pRPT = function_block(RPT, keys_48[curr_round - 1], s_box[curr_round - 1])\n    xRPT = [x ^ y for x, y in zip(LPT, pRPT)]\n    LPT = RPT\n    RPT = xRPT\n    curr_round += 1\n  #\n  ct_64 = RPT + LPT\n  cipher_text = \"\".join(list(map(lambda x: chr(x), bin_list_asciirizer(ct_64))))\n  return cipher_text, ct_64\n\ndef simplified_DES():\n  s_box_1 = [[14,\t4, 13, 1,\t2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7], \n  [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8], \n  [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0], \n  [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]]\n\n  s_box_2 = [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],\n  [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],\n  [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],\n  [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]]\n\n  s_box_3 = [[12, 1, 10, 15, 9,\t2, 6,\t8, 0, 13, 3, 4,\t14,\t7, 5, 11],\n\t[10, 15, 4,\t2, 7,\t12,\t9, 5,\t6, 1, 13,\t14,\t0, 11, 3,\t8],\n\t[9,\t14,\t15,\t5, 2,\t8, 12, 3,\t7, 0,\t4, 10, 1,\t13,\t11,\t6],\n\t[4,\t3, 2,\t12,\t9, 5,\t15,\t10,\t11,\t14,\t1, 7,\t6, 0,\t8, 13]]  \n\n  plain_text = input(\"Enter the 8 character text: \")[:8]\n  pt_64 = ascii_list_binarizer(list(map(lambda x: ord(x), list(plain_text))))\n  key_1 = input(\"Enter the first key: \")[:6]\n  key_1_48 = ascii_list_binarizer(list(map(lambda x: ord(x), list(key_1))))\n  key_2 = input(\"Enter the second key: \")[:6]\n  key_2_48 = ascii_list_binarizer(list(map(lambda x: ord(x), list(key_2))))\n  key_3_48 = ascii_list_binarizer(list(map(lambda x: ord(x), list(reversed(key_2)))))\n  print(\"A \\033[38;5;189mthird key\\033[0m has been derived internally from the keys entered.\")\n\n  cipher_text, ct_64 = simplified_DES_encryption(pt_64, keys_48 = (key_1_48, key_2_48, key_1_48), s_box = (s_box_1, s_box_2, s_box_3), noofrounds = 3)\n  print(\"\\033[38;5;119mCipher Text:\", cipher_text, \"\\033[0m\")\n  plain_text, pt_64 = simplified_DES_encryption(ct_64, keys_48 = (key_1_48, key_2_48, key_1_48), s_box = (s_box_3, s_box_2, s_box_1), noofrounds = 3)\n  print(\"\\033[38;5;197mDeciphered Text:\", plain_text, \"\\033[0m\")\n\nsimplified_DES()",
      "comments": {
        "1": "#~ Implementing a simplified version of Data Encryption Standard (DES) (64 bits (8 chars.) input)",
        "17": "# regulation -> compulsorily 8 bits to represent every number",
        "49": "# flattening",
        "59": "# regulation -> since there is gonna be numbers from 0 - 15 in any of the s_box cell, 4 bits compulsion enforced on binary repr. of these numbers to make 4 x 8 = 32 bits",
        "67": "#~ Expanded RPT which is a list(8 members) of lists(6 members) which total upto 48 bits (This will be the naming convention throughout the program for 2D lists)",
        "70": "#~ XOR with the key's 48 bits",
        "74": "#~ Reducing the 48 RPT bits to 32",
        "83": "# do the crisscross",
        "89": "# now do the final \"straight\" output"
      },
      "OP_ss_dir": "OP_ss/Simplified_DES.py"
    },
    "Simplified_RSA_Algorithm.py": {
      "lang": "py",
      "code_string_literal": "import math\n#\ndef make_closest_prime(number, *exclude):\n  i = 2\n  while i <= int(number / 2) + 1:\n    if number % i == 0:\n      number += 1\n      while number in exclude:\n        number += 1\n      i = 2\n    else:\n      i += 1\n  return number\n\ndef relatively_prime_finder(totient, *exclude):\n  for i in range(2, int(totient / 2) + 1):           #\n    if math.gcd(i, totient) == 1:\n      if i not in exclude:\n        return i\n\ndef extended_euclidean_algorithm(\u03a6n, e):\n  exe_table = {'x': [1, 0], 'y': [0, 1], 'r': [\u03a6n, e], 'q': [-1]}         #\n  \n  while exe_table['r'][-1] != 1:                                         #\n    exe_table['q'].append(int(exe_table['r'][-2] / exe_table['r'][-1]))  #\n    exe_table['x'].append(exe_table['x'][-2] - exe_table['x'][-1] * exe_table['q'][-1])   #\n    exe_table['y'].append(exe_table['y'][-2] - exe_table['y'][-1] * exe_table['q'][-1])\n    exe_table['r'].append(exe_table['r'][-2] % exe_table['r'][-1])\n\n  return (exe_table['y'][-1]) % \u03a6n         #\n\ndef RSA():\n  PT = int(input(\"Enter the number to be encrypted: \"))\n  print(\"Enter p and q which are public, mutually accepted numbers between the sender and the receiver\")\n  p = len(input(\"Enter the string p, (length should be > 10): \"))\n  if p < 10:\n    raise ValueError(\"Cannot have number lesser than 10 for 'p'\")\n  while True:\n    q = len(input(\"Enter the passphrase q, (length should be > 10 \\033[1mand not as same as p\\033[0m): \"))\n    if q < 10:\n      raise ValueError(\"Cannot have number lesser than 10 for 'q'\")\n    elif q == p:\n      print(\"Length of q cannot be p!\")\n    else:    \n      break\n  p = make_closest_prime(p)\n  q = make_closest_prime(q, p)\n\n  print(f\"p = {p}, q = {q}\")\n  n = p * q\n  \u03a6n = (p - 1) * (q - 1)\n  print(f\"n = {n}, \u03a6n = {\u03a6n}\")\n  e = relatively_prime_finder(\u03a6n, p, q)\n  print(f\"e = {e}\")\n  d = extended_euclidean_algorithm(\u03a6n, e)\n  print(\"d = \", d)\n\n  PT %= n\n  print(\"Plain Text: \", PT)\n  CT = (PT ** e) % n \n  print(\"Cipher Text: \", CT)\n\n  PT = (CT ** d) % n \n  print(\"Plain Text: \", PT)\n\nRSA()",
      "comments": {
        "2": "#TODO - Rectify make_prime, add conditions for 0 and 1 length p and q ",
        "16": "# since e has to be less than totient ",
        "22": "# initial conditions for every extended Euclidean algorithm table",
        "24": "# The stopping condition in r column whose corr. y is our 'd'  -> (This was a doubt too, why is the answer of y considered as d and what does the value of x signify)",
        "25": "# for this column, the current value (one which is just getting appended) is always the division of the pre-previous and previous",
        "26": "# for both 'x' and 'y' columns, the current value comes out from the formula xi = xi-2 - xi-1*qi-1 ",
        "30": "# taking care of additive inverse if applicable"
      },
      "OP_ss_dir": "OP_ss/Simplified_RSA_Algorithm.py"
    },
    "Vigenere_Cipher_26.py": {
      "lang": "py",
      "code_string_literal": "#\n#\n\n#\nvigenere_table = [[chr((i + j - 65) % 26 + 65) for j in range(26)] for i in range(65, 91)]\n\"\"\"\nTable formation:\nAs Vigenere table is 26 caesar ciphers essentially, I used that logic to form the table (now, lol) row by row\n1. i goes from 65 - 90 i.e the ASCII values for A - Z. \n2. For each i, j goes 0 - 25, so, \n3. (i + j) goes 65 - 90 for i = 65 j = [0, 25]; 66 - 91 for i = 66 and j = [0, 25], and so on\n4. For e.g, when (i + j) = 91, (i + j - 65) = 26, (i + j - 65) % 26 = 0 and 0 + 65 would be 65 which is ASCII for A, hence implementing caesar cycle properly (same logic as done in the standalone caesar cipher but with 26 chars. instead of 95)\n\"\"\"\n#\n\ndef vigenere_encryption(plain_text, keyword):\n  cipher_text = \"\"\n  for i in range(len(plain_text)):                                                     #\n    cipher_text += vigenere_table[ord(keyword[i]) - 65][ord(plain_text[i]) - 65]       #\n  return cipher_text\n\ndef vigenere_decryption(cipher_text, keyword):\n  plain_text = \"\"\n  for i in range(len(cipher_text)):\n    plain_text += chr((vigenere_table[ord(keyword[i]) - 65].index(cipher_text[i])) + 65)      #\n  return plain_text\n  \ndef vigenere_cipher():\n  plain_text = input(\"Enter the plain text: \").upper()\n  keyword = input(\"Enter the keyword: \")[:len(plain_text)].upper()  #\n  while len(keyword) < len(plain_text):\n    keyword += keyword\n  keyword = keyword[:len(plain_text)]\n  #\n\n  cipher_text = vigenere_encryption(plain_text, keyword)\n  print(\"Encrypted Text: \", cipher_text)\n  \n  plain_text = vigenere_decryption(cipher_text, keyword)\n  print(\"Decrypted Text: \", plain_text)\n\nvigenere_cipher()",
      "comments": {
        "1": "#~ Implementing Vigenere Cipher for uppercase English alphabets",
        "2": "# https://pages.mtu.edu/~shene/NSF-4/Tutorial/VIG/Vig-Base.html",
        "4": "#* vigenere_table is a list of 26 lists, with each list having 26 chars. starting one step ahead successively",
        "14": "# alternatively, i think dictionary of dictionaries could've also been used",
        "18": "# range used so that 'i' can be commonly used for both keyword and pt",
        "19": "#* The cipher text characters are the characters at the intersection of keyword(X-axis)(rows) and plaintext(Y-axis)(columns), -65 for 65 -> 90 -->> 0 -> 25 for table indices",
        "25": "#* Plain text is the column index (converted to \u03b1\u00df) of the cipher_text char. in the keyword char.'s corresponding row",
        "30": "# precaution if the len(keyword) entered is > len(plain_text)",
        "34": "# print(keyword)"
      },
      "OP_ss_dir": "OP_ss/Vigenere_Cipher_26.py"
    }
  }
}